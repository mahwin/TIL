# 타입스크립트 암기장

작성일: 2023년 11월 19일 오후 5:16

- let n = null
    - any로 추론되니 조심
- let n = undefiend
    - any로 추론되니 조심
- let a : {} = 'string'
    - 어색해 보이지만 정상적으로 타이핑 가능한 코드임.
    - {} 는 null과 undefined를 제외한 모든 값임.
    - 객체가 아니라는 사실 꼭 기억
    
- const arr = [];
    - 빈 배열은 any[]로 추론되니 조심
- const obj = {’key’:’value’}
    - 객체의 경우 const를 붙여도 넓게 추론됨. readonly를 쓰고 싶다면 as const 접미사 붙이기
    - const obj = {’key’:’value’} as const
- const tuple : readonly [number,boolean,string]=[1,false,'유석'];
    - 튜플 타입도 push, pop, unshift, shift 등의 메서드에 대해서는 열려있음
    - readonly를 붙이면 push, pop, unshift, shift 등의 메서드 막을 수 있음
- unkonwn은 모든 타입에 대입할 수 있지만, 그 후 어떤 동작도 할 수 없다.
- try catch 문에서 error의 타입은 any와 unknown 외의 타입을 직접 표기할 수 없다
    
    ```tsx
    catch(e){
    	const error = e as Error; // 이렇게 타입 assertion해서 사용
    }
    ```
    
- as unknown as myType으로 강제로 어떤 타입이라고 주장할 수 있다
    - 책임은 개발자 몫
- never는 모든 타입에 대입할 수 있다.
- void 타입은 반환값이 없다는 것이 아니라 반환값을 무시하도록 하는 것이다.
    - 리턴 값이 있어도 void를 타이핑할 수 있음.
        - ()⇒ void = () ⇒ 3 무시 OO
    - 반환 값의 type만 표기하는 경우 무시 XX
        - () : void ⇒ 3  무시 XX
- 함수 선언문의 반환 값이 없는 경우 리턴 타입으로 void가 추론된다
    - function 선언문(){throw new Error(’!’)} ⇒ void
- 함수 표현식의 반환 값이 없는 경우 리턴 타입으로 never가 추론된다
    - const 표현식 () {throw new Error(’!’)} ⇒ never
- 객체 리터럴과 객체를 참조하는 변수는 타입 검사 방식이 다르다.
    - 객체 리터럴 일 때만 잉여 속성 검사를 진행한다.
        
        ```tsx
        interface IType = { name: string;}
        const 객체리터럴:IType {name:'크롱',say:'hi'} 
        ```
        
    - 객체를 참조하는 변수
        
        ```tsx
        const 참조변수 = {name:'크롱',say:'hi'} 
        const isOk : IType = 참조변수;
        ```
        
- keyof typeof 객체를 통해 객체의 key 값들을 union 타입으로 만들 수 있다.
    
    ```tsx
    const myName ={
    	first:"정",
    	second:"유",
    	third:"석"
    }
    
    keyof typeof myName => "first" | "second" | "third"
    ```
    
- keyof typeof와 인덱스 접근 타입을 활용하면 객체의 value 값들을 union 타입으로 만들 수 있다.
    
    ```tsx
    type Keys = keyof typeof myName;
    type values =typeof myName[Keys]; // string
    ```
    
    - keyof any는 string| number | symbol의 유니온이다.
- 객체 타입 복사하는 방법
    
    ```tsx
    interface M {
      first: string,
    	marrined: boolean
    }
    type TM = {
    	[key in keyof M] : M[key]
    }
    
    ```
    
- - 연산자를 통해 수식어를 제거할 수도 있다.
    
    ```tsx
    interface M {
     readonly first: string,
     marrined?: boolean
    }
    type TM = {
    	-readonly [key in keyof M]-? : M[key]
    }
    
    type TM = {
      first: string,
    	marrined: boolean
    }
    
    ```
    
- &, | 연산자 사용 예시
    
    ```tsx
    type D = {} & (string | null ); // string
    type F = unknown | {}; // unknown
    type F = unknown & {}; // {}
    type I = null & {a:'b'}; // never
    type H = {a:'b'} & number; // never가 아닌게 주의할 점.
    													 // {a:'b'} & number 이런 타입임 그냥..
    													 // null, undefined 빼고 채워진 객체면 그냥 그대로 타입임
    ```
    
- inteface는 extends로 type 별칭은 &로 타입 상속을 할 수 있다.
    - type 별칭과 interface를 섞어서 상속할 수도 있으며, 여러개를 한 번도 가능하다.
    
    ```tsx
    type Human {
    	name:string;
    }
    interface Mahwin extends Human {
    	speak():void;
    }
    interface YouSeock extends Human {
    	coding():void;
    }
    interface Me extends Mahwin,YouSeock {}
    ```
    
- 객체에 타이핑을 할때 넓은 타입에 좁은 타입을 대입할 수 있지만, 역은 불가능하다.
    
    ```tsx
    interface IWide {
    	name:string;
    }
    
    interface INarrow extends IWide {
    	age:number;	
    }
    
    // 잉여 속성 검사 무시하려고 참조 값 만듬.
    const wideObj = {name:"zero"};
    const narrowObj = {name:"zero" , age:32};
    
    const narrowToWide : IWide = narrowObj // ok
    const wideToNarrow : INarrow = wideObj // error 
    ```
    
- 튜플은 배열보다 좁은 타입이다.
    - 튜플을 배열에다 대입할 순 있지만, 반대는 불가능하다.
    
    ```tsx
    let a:['hi','read'] = ['hi','read'];
    let b: string[] = ['hi','read'];
    b=a; // ok
    a=b; // error 넓은 타입인 배열을 튜플 타입에 넣으려니 error 발생
    ```
    
- 배열과 튜플에서 readonly 수식어
    - readonly 수식어가 붙은 타입이 더 넓음
        - 여러 method가 빠지니까 더 넓은 타입임.
    
    ```tsx
    let a : readonly string[] = ['a','b'];
    let b : string[] = ['a','b'];
    a=b; 
    b=a; // error readonly가 붙은 a가 더 넓은 타입이라 에러
    ```
    
    - readonly 튜플과 일반 배열의 타입 비교
    
    ```tsx
    let a:readonly ['a','b'] = ['a','b'];
    let b:string[] = ['a','b'];
    a=b; // error 넓은 타입을 좁은 타입에 넣으면 안된다 (튜플,배열)
    b=a; // error readonly가 붙으면 일반 배열보다 넓은 의미라서 
    ```
    
- 객체는 optional이 붙은 타입이 더 넓은 타입이다.
- 객체는 readonly가 있든 없든 타입이 같다면 서로 대입할 수 있다.
- 타입스크립트는 구조가 같다면 같은 타입으로 판단한다.
    
    ```tsx
    interface 주식 {name:string; price:number};
    interface 코인 {name:string; price:number};
    const 에이다 : 코인 = {amount:1,price:200};
    const 셀트리온 : 주식 = 에이다;
    ```
    
- 제네릭
    - 위치
    
    ```tsx
    interface 이름<>
    type 이름<>
    class 이름<>
    function 이름<N,A>(name:N,age:A){return {name,age}};
    const 함수 = <N,A>(name:N,age:A)=>({name,age})
    ```
    
    - default type도 가능
    
    ```tsx
    interface 이름<T=string>
    ```
    
    - 매개변수에 extends 문법을 사용해 매개변수 타입에 제약을 걸 수 있다.
    
    ```tsx
    interface E<A extends number, B= string>{
    	a:A,
    	b:B,
    }
    ```
    
    - ⭐️⭐️⭐️자주 사용되는 제약⭐️⭐️⭐️
    
    | <T extends object> 모든 객체  |
    | --- |
    | <T extends any[]> 모든 배열 |
    | <T extends (…args:any⇒any))> 모든 함수 |
    | <T extends abstract new (…args:any)⇒ any> 생성자 타입 |
    | <T extends keyof any> 속성의 키  // string | number | symbol |
- 컨디셔널 타입
    - 특정 타입 extneds 다른 타입 ? 참일 때 타입 : 거짓일 때 타입
    
    ```tsx
    type Start = string | number;
    type New = Start extends string | number ? Start[] : never;
    ```
    
    - 객체에 value 타입을 기준으로 선별하는 예시 코드
    
    ```tsx
    type OmitByType<O,T> ={
    	[K in keyof O as O[K] extends T  ? K : never]: O[K];
    }
    
    type Result = OmitByType<{
    	name:string;
    	age:number;
    	married:boolean;
    	rich:boolean
    }, boolean>;
    
    type Result = { rich:boolean, married:boolean }
    ```
    
    - 검사하려는 타입이 제네릭이면서 유니온 타입이면 분배법칙이 적용된다
        - string | number를 string[]으로 만들어보자
    
    ```tsx
    type Union = string|number;
    type Arr<T> = T extends string ? T[] :never;
    ```
    
    - boolean의 경우 true|false의 유니온 타입임을 조심하자.
        
        ```tsx
        type Result<T> = T extends boolean ? T[] :never;
        
        type B = Result<boolean> // true[] false[]
        ```
        
    - []로 감싸서 분배 법칙을 막을 수 있다.
        
        ```tsx
        type Result<T> = [T] extends [boolean] ? T[] :never;
        
        type B = Result<boolean> // boolean[]
        ```
        
    - never 타입도 분배법칙의 대상이다
        
        ```tsx
        type R<T> = T extends string ? true : false;
        type RR = R<never>; 
        // never는 모든 타입을 받을 수 있어서 true같지만 RR의 타입은 never임
        // 이는 never도 분배법칙이 일어나기 때문이고, never는 공집합으로 아무것도 실행 안함을 의미. 
        ```