작성일: 2023년 11월 18일 오후 9:35

### 타입스크립트의 암기할 내용을 정리한 문서

- let n = null
  - any로 추론되니 조심
- let n = undefiend
  - any로 추론되니 조심
- let a : {} = 'string'
  - 어색해 보이지만 정상적으로 타이핑 가능한 코드임.
  - {} 는 null과 undefined를 제외한 모든 값임.
  - 객체가 아니라는 사실 꼭 기억
- const arr = [];
  - 빈 배열은 any[]로 추론되니 조심
- const obj = {’key’:’value’}
  - 객체의 경우 const를 붙여도 넓게 추론됨. readonly를 쓰고 싶다면 as const 접미사 붙이기
  - const obj = {’key’:’value’} as const
- const tuple : readonly [number,boolean,string]=[1,false,'유석'];
  - 튜플 타입도 push, pop, unshift, shift 등의 메서드에 대해서는 열려있음
  - readonly를 붙이면 push, pop, unshift, shift 등의 메서드 막을 수 있음
- unkonwn은 모든 타입에 대입할 수 있지만, 그 후 어떤 동작도 할 수 없다.
- try catch 문에서 error의 타입은 any와 unknown 외의 타입을 직접 표기할 수 없다
  ```tsx
  catch(e){
  	const error = e as Error; // 이렇게 타입 assertion해서 사용
  }
  ```
- as unknown as myType으로 강제로 어떤 타입이라고 주장할 수 있다
  - 책임은 개발자 몫
- void 타입은 반환값이 없다는 것이 아니라 반환값을 무시하도록 하는 것이다.
  - 리턴 값이 있어도 void를 타이핑할 수 있음.
    - ()⇒ void = () ⇒ 3 무시 OO
  - 반환 값의 type만 표기하는 경우 무시 XX
    - () : void ⇒ 3 무시 XX
- 함수 선언문의 반환 값이 없는 경우 리턴 타입으로 void가 추론된다
  - function 선언문(){throw new Error(’!’)} ⇒ void
- 함수 표현식의 반환 값이 없는 경우 리턴 타입으로 never가 추론된다
  - const 표현식 () {throw new Error(’!’)} ⇒ never
