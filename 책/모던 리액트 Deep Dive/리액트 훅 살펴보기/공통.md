## 훅의 규칙

리액트에서 제공하는 훅은 사용하는 데 몇 가지 규칙이 존재한다.

1. 최상위에서만 훅을 호출해야 한다. 반복문이나 조건문은 중첩된 함수 내에서 훅을 실행할 수 없다. 이 규칙을 따라야만 컴포넌트가 렌더링될 때마다 항상 동일한 순서로 훅이 호출되는 것을 보장할 수 있다.

2. 훅을 호출할 수 있는 것은 리액트 함수 컴포넌트, 혹은 사용자 정의 훅의 두 가지 경우뿐이다. 일반 자바스크립트 함수에서 사용할 순 없다.

리액트 훅들은 index와 같은 키를 기반으로 구현돼 있다. 이 키는 훅이 호출된 순서를 기억하고 있다. 만약 훅을 중첩된 함수 내에서 호출한다면, 리액트는 훅이 호출된 순서를 기억하지 못하고, 훅이 호출된 순서대로 실행되지 않을 수 있다.

```javascript
function Component() {
  const [count, setCount] = useState(0);
  const [required, setRequired] = useState(false);

  useEffect(() => {}, [count, requeired]);
}
```

위 컴포넌트는 파이버에서 다음과 같이 저장된다.

```javascript
{
  memoizedState: 0, // setCount 훅
  baseState:0,
  queue:{}
  baseUpdate:null,
  next:{
    memoizedState: false, // setRequired 훅
    baseState: false,
    queue: {},
    baseUpdate: null,
    next:{
      //useEffect 훅
      memoizedState: :{
        tag:192,
        create:()=>{},
        destroy: undefined,
        deps:[0,false],
        next:{}
      },
      baseState:null,
      queue:null,
      baseUpdate:null,
    }
  }
}
```

리액트 훅은 파이버 객체의 링크드 리스트의 호출 순서에 따라 저장된다. 그 이유는 각 훅이 파이버 객체 내에서 순서에 의존해 state나 effect의 결과에 대한 값을 저장하고 있기 떄문이다. 이렇게 고정된 순서에 의존해 이전 값과 비교와 실행이 가능해진다.

## 사용자 정의 훅과 고차 컴포넌트

### 사용자 정의 훅

서로 다른 컴포넌트에서 같은 로직을 사용하고 싶을때 사용자 정의 훅을 이용할 수 있다.
이 사용자 규칙은 use로 시작하는 함수로 만들어야한다.

```typescript
import { useEffect, useState } from "react";

export function useFecth<T>(
  url: string,
  { method, body }: { method: "GET" | "POST"; body?: XMLHttpRequestBodyInit }
) {
  const [result, setResult] = useState<T | undefined>();
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [ok, setOk] = useState<boolean | undefined>();
  const [status, setStatus] = useState<number | undefined>();

  useEffect(() => {
    const abortController = new AbortController();
    (async () => {
      setIsLoading(true);
      const response = await fetch(url, {
        method,
        body,
        signal: abortController.signal,
      });
      setOk(response.ok);
      setStatus(response.status);
      if (response.ok) {
        const json = await response.json();
        setResult(json);
      }
    })();

    return () => abortController.abort();
  });
  return { ok, result, isLoading, status };
}

interface Todo {
  userId: number;
  id: number;
  title: string;
  completed: boolean;
}

export default function App() {
  const { result, isLoading, ok, status } = useFecth<Todo[]>(
    "https://jsonplaceholder.typicode.com/todos",
    { method: "GET" }
  );

  useEffect(() => {
    if (!isLoading) {
      console.log("fetchResult >>", status);
    }
  }, [status, isLoading]);

  return (
    <div>
      {ok ? (
        <ul>
          {result?.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      ) : (
        <div>Failed to fetch</div>
      )}
    </div>
  );
}
```

위 처럼 사용자 정의 훅을 만들어서 사용하면 컴포넌트에서 로직을 분리할 수 있다.

use-Hooks, react-use,ahooks 등에서 커스텀 훅의 좋은 예시를 볼 수 있으니 학습하자!!!

## 고차 컴포넌트

고차 컴포넌트는 컴포넌트 자체의 로직을 재사용하기 위한 방법이다. 리액트에서 가장 유명한 고차 컴포넌트는 리액트에서 제공하는 API 중 하나인 React.memo이다.

### React.memo란?

리액트 컴포넌트는 부모가 렌더링될 때 마다 렌더링 된다. 이는 자식 컴포넌트가 내려받는 props 와는 상관없다.

```javascript
import { useEffect, useState } from "react";

function C() {
  useEffect(() => console.log("자식 렌더링"));

  return <>자식</>;
}

export default function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  useEffect(() => console.log("부모 렌더링"));

  return (
    <>
      <button onClick={() => setCount(count + 1)}>증가</button>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <C />
    </>
  );
}
```

C 컴포넌트는 props로 내려받는 값이 없어도 state가 변경되면 재랜더링된다.

컴포넌트의 렌더링을 방지하기 위해 React.memo를 사용할 수 있다.

```javascript
const C = memo(() => {
  useEffect(() => console.log("자식 렌더링"));

  return <>자식</>;
});
```

useMemo도 정확히 같은 일들을 할 수 있지만, 일관성을 위해 컴포넌트의 메모이제이션을 위해 만들어진 memo를 사용하는 것이 좋다.

### 고차 함수

리액트의 함수 컴포넌트도 결국 함수이기 때문에 고차 컴포넌트를 만들기 전에 고차 함수를 알아보자. 고차 함수는 함수를 인수로 받거나 결과로 반환하는 함수이다.

Array.prototype.map,Array.prototype.forEach,Array.prototype.some... 등이 고차 함수의 대표적인 예시이다.

### 고차 함수를 활용한 리액트 고차 컴포넌트

사용자 인증 정보에 따라서 인증된 사용자에게는 개인화된 컴포넌트를 아니라면 공통 컴포넌트를 보여주는 컴포넌트를 짜보자.

```typescript
import { ComponentType } from "react";

interface LoginProps {
  loginRequired?: boolean;
}

function withLoginComponent<T extends object>(Component: ComponentType<T>) {
  return function (props: T & LoginProps) {
    const { loginRequired, ...restProps } = props;

    if (loginRequired) {
      return <>로그인이 필요합니다.</>;
    }
    return <Component {...(restProps as T)} />;
  };
}

const Component = withLoginComponent((props: { value: string }) => {
  return <h3>{props.value}</h3>;
});

export default function App() {
  const isLogin = false;
  return <Component value="Hello" loginRequired={isLogin} />;
}
```

고차함수는 훅에 비해서 더욱 큰 영향력을 컴포넌트에 미칠 수 있다. 커스텀 훅이 use로 시작했던 것처럼 고차함수도 특정한 네이밍 규칙이 존재하는데, with로 시작하는 것이 그 예시이다.

주의할 점은 반드시 props를 임의로 수정, 추가, 삭제하는 일은 없어야한다. props를 고차 컴포넌트에서 변경하게 되면 컴포넌트 개발자가 언제든 props가 변경될 지 모른다는 불안감을 가져야한다.

고차함수를 중첩해서 사용하는 것은 코드 가독성을 떨어뜨리고, 디버깅을 어렵게 만들 수 있다. 따라서 최소한으로 사용하는 것이 좋다.
