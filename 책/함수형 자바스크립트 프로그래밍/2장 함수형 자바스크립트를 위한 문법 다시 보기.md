추상화, 모듈화, 패턴, 클래스, 프레임워크, 아키텍처 등에서 잠시 눈을 돌려 자바스크립트 문법과 기본적인 동작에 집중하는 것이 중요하다.

## 2.1 객체와 대괄호 다시 보기

### 2.1.1 난해해 보이는 문법들을 확인하는 모겆ㄱ

자바스크립트 라이브러리 혹은 프레임워크들에서 난해한 문법들이 사용되는 경우가 많은데, 다음과 같은 목적들을 가지고 있다.

1. 코드를 짧게 만들기
2. 추상화의 다양한 기법
3. if를 없애기 위해
4. 특별한 로직을 위해
5. 캐시를 위해
6. 은닉을 위해
7. 함수를 선언하고 참조하기 위해
8. 컨텍스트를 이어주기 위해

### 2.1.2 객체와 key

객체에 key,value는 {},.,[] 을통해 설정할 수 있다.

```javascript
const obj = {(3 % 2 === ? "odd" : "even"): 5} // Error
const obj = {[3 % 2 === ? "odd" : "even"]: 5} // OK
obj[3%2 === ?'odd':'even'] = 5; // OK
```

### 2.1.3 함수나 배열에 달기

배열에 숫자가 아닌 key를 사용할 수 있다.

```javascript
const obj = [];
obj.a = 1;
obj; // [a: 1]
obj.length; // 0
```

- 단 length가 늘어나진 않는다.

length라고 특별한 값은 아니다.

```javascript
const arr = Array.from({ length: 10 }, () => {});
arr.length; // 10

arr["len" + "gth"]; // 10

arr["len" + "gth"] = 5;
arr.length; // 5
```

### 2.1.4 delete

자바스크립트에서는 기본 객체의 메서드나 프로퍼티도 지울 수 있다.

```javascript
delete Array.prototype.push;
const arr = [];
arr.push(3); // Error arr.push is not function
```

### 2.1.5 코드가 실행될 수 있는 영역

객체에서는 키를 대괄호로 참조하면, 대괄호 사이에서 코드를 실행할 수 있다. 코드를 실행할 수 있따는 의미는 거의 모든 일을 수행할 수 있다는 의미이고 이는 높은 수준으로 추상화할 수 있다는 말이 된다.

## 2.2 함수 정의 다시 보기

### 2.2.1 기본 정의

함수를 정의한느 기본 3가지 방법은 아래와 같다.

```javascript
function add() {}
const add = function () {};
const m = { add: function () {} };
```

### 2.2.2 호이스팅

호이스팅이란 변수나 함수가 어디서 선언되든지 해당 스코프 최상단에 위치하게 되어 동일 스코프 어디서든 참조할 수 있는 것을 말한다.

### 2.2.7 유명 함수

```javascript
const f1 = function f() {
  console.log(f);
};
```

함수를 값으로 다루면서 익명이 아닌 f()처럼 이름을 지은 함수를 유명함수라고 한다. 함재귀 등을 이용할 때 유명 함수를 사용해서 자기 자신을 가리키기 편리하다.

먼저, 익명 함수에서 자기 자신을 참조하는 방법을 알아보자.

```javascript
let f1 = function () {
  console.log(f1);
};

f1(); // 정상

let f2 = f1;
f1 = "!!";
f2(); // "!!";
```

참조는 가능하지만 변경에 안전하지 못 하다. arguments.callee를 사용하면 함수 내부에서 자기 자신을 참조할 수 있다.

```javascript
let f1 = function () {
  console.log(arguments.callee);
};

f1(); // 정상

let f2 = f1;
f1 = "!!";
f2(); // 정상
```

정상적으로 동작하지만 strict mode에서는 arguments.callee를 사용할 수 없다.

```javascript
let f1 = function f() {
  console.log(f);
};

f1(); // 정상

let f2 = f1;
f1 = "!!";
f2(); // 정상
```

위와 같은 유명 함수를 선언하면 안전하게 자기자신을 참조할 수 있다. 또, 유명 함수식의 함수 이름은 내부 스코프에서만 참조가 가능하다.

```javascript
let f = 3;
let f1 = function f() {
  console.log(f);
};

f = null;

f1(); // 정상적으로 f 출력
f1.name; // f
```

### 2.2.8 유명 함수를 이용한 재귀

```javascript
function flatten(arr) {
  return (function f(arr, new_arr) {
    arr.forEach((v) => {
      Array.isArray(v) ? f(v, new_arr) : new_arr.push(v);
    });
  })(arr, []);
}
```

flatten 함수는 재귀, 유명함수, 즉시 실행 등의 기법이 사용되었다.

즉시 실행이 없을 경우

```javascript
function flatten2(arr, new_arr) {
  arr.forEach((v) => {
    Array.isArray(v) ? flatten2(v, new_arr) : new_arr.push(v);
  });
  return new_arr;
}

flatten2([1, [2, 3], [4, [5, 6]]], []); // 끝에 항상 []를 넣어줘야 한다.

function flatten3(arr, new_arr = []) {
  arr.forEach((v) => {
    Array.isArray(v) ? flatten3(v, new_arr) : new_arr.push(v);
  });
  return new_arr;
}
```

## 2.3 함수 실행과 인자 그리고 점 다시 보기

### 2.3.1 () 다시 보기

함수를 실행하는 방법에는 (), call, apply가 있고, 함수 안에서는 arguments와 this 키워드를 사용할 수 있다.

### 2.3.2 인자 다시 보기

```javascript
function test(a, b) {
  b = 10;
  console.log(arguments);
}

test(1, 2); // [1,10]

function test2(a, b) {
  arguments[1] = 10;
  console.log(b);
}

test2(1, 2); // 10
```

arugments와 매개변수는 참조하고 있는 것마냥 연결되어 변경된다. 해당 부분에 해대서 제대로 인지하고 있어야 한다.

### 2.3.4 call, apply 다시 보기

```javascript
test.call(undefined, 1, 2, 3);
test.call(null, 1, 2, 3);
test.call(void 0, 1, 2, 3);
```

call의 경우 첫 번째 인자가 this로 바인딩 되는데 undefined인 경우 글로발 디스가 바인딩된다. apply는 매개변수를 전달하는 방식만 다르고 동일하다.

### 2.3.5 call의 실용적 사례

```javascript
let slice = Array.prototype.slice;

function toArray(data) {
  return slice.call(data);
}
function rest(data, n) {
  return slice.call(data, n || 1);
}
```

Array.prototype.slice의 경우, 키를 숫자로 갖고 length를 갖는 객체이기만 하면 Array가 아닌 값이어도 call을 통해 Array.prototype.slice를 사용할 수 있다.
