## 1.1 함수형 프로그래밍이란?

많은 사람들이 함수형 프로그래밍은 객체지향과 완전한 대척점에 있다고 생각하거나 그런 주장을 하기도 한다. 이것은 오해다. 결국에는 함께 동작해야 한다. 현대 프로그래밍에서 다루는 값은 대부분 객체이므로 함수형 프로그래밍에서도 결국 개체를 다뤄야 한다. 다만 기능 확장을 객체의 확장으로 풀어가느냐 함수 확장으로 풀어가느냐의 차이다. 객체를 확장하느냐 객체를 다루는 함수를 늘리느냐의 차이이며 추상화의 단위가 클래스이냐 함수이냐의 차이이다.

리팩토링의 핵심은 중복을 제거하고 의도를 드러내는 것이다.

객체지향 프로그래밍이 약속된 이름의 메서드를 대신 실행해 주는 식으로 외부 객체에게 위임을 한다면, 함수형 프로그래밍은 보조 함수를 통해 완전히 위임하는 방식을 취한다. map, filter, find 함수들은 들어온 데이터의 구조에 대해서는 들여다보지 않는다. 그저 함수를 실행할 뿐이다. 이러한 함수로서 행위를 정의하는 것은 높은 다형성과 안정성을 보장한다.

## 1.4 함수형 자바스크립트를 위한 기초

유명한 함수의 사용법을 익히는 것도 중요하지만, 무엇보다 함수를 다루는 다양한 방법들을 잘 익히는 것이 중요하다. 일급 함수, 클로저, 고차 함수, 콜백 패턴, 부분 적용, arguments 객체 다루기, 함수 객체의 메서드(bind, call, apply) 등이 있다.

### 1.4.1 일급 함수

일급은 값으로 다룰 수 있다는 의미이다. 값으로 다룰 수 있으면 아래와 같은 일이 가능하다.

- 변수에 담을 수 있다.
- 함수나 메서드의 인자로 넘길 수 있다.
- 함수나 메서드에서 리턴할 수 있다.

보통 일급 함수는 위의 조건 외에 3가지 추가적인 조건을 만족한다.

- 아무 때나 선언이 가능하다.
- 익명으로 선언할 수 있다.
- 익명으로 선언한 함수도 함수나 메서드의 인자로 넘길 수 있다.

```javascript
function f1() {}
const a = typeof f1 === "function" ? f1 : function () {};

function f2() {
  return function () {};
}

(function () {})();

function callAndAdd(a, b) {
  return a() + b;
}

callAndAdd(function () {
  return 10;
}, 20);
```

### 1.4.2 클로저

스코프란 변수를 어디에서 어떻게 찾을지를 정한 규칙으로, 여기에서 다루는 스코프는 함수 단위의 변수 참조에 대한 것이다. 함수는 변수 찾조 범위를 결정하는 중요한 기준이다. 함수가 중첩되어 있다면 스코프들 역시 중첩되어 생겨난다.

- 클로저는 자신이 생성될 때의 환경을 기억하는 함수이다.
- 클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수다.
  - 때라는 것에 주의해야 한다. 클로저가 기억하는 환경은 결국 변수이고 변수의 값은 언제나 변할 수 있기 때문이다.

자바스크립트의 모든 함수는 글로벌 스코프에 선언되거나 함수 안에서 선언된다. 자바스크립트의 모든 함수는 상위 스코프를 가지며 모든 함수는 자신이 정의되는 순간의 실행 컨텍스트 안에 있다.

자바스크립트의 모든 함수는 글로벌 스코프에 선언되거나 함수 안에서 선언된다. 자바스크립트의 모든 함수는 상위 스코프를 가지며 모든 함수는 자신이 정의되는 순간의 실행 컨텍스트 안에 있다. 자바스크립트의 모든 함수는 어느 곳에서 생성하든 어떤 방법으로 생성하든 자신이 생성될 때의 환경을 기억할 수 있다.

클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수 중 자신이 언젠가 실행될 때 사용할 변수들만 기억하여 유지시키는 함수이다.

```javascript
let a = 3;
let b = 5;

function add() {
  return a + b;
}
```

위 함수는 클로저가 아니다. 글로벌 스코프에서 선언된 모든 변수는 그 변수를 사용하는 함수가 있는지 없는지와 관계없이 유지된다. a와 b변수가 add 함수에 의해 사라지지 못하는 상황이 아니므로 add는 클로저가 아니다.

그렇다면 함수 내부의 함수만 클로저가될 조건을 만족할까?

그렇지 않다. Node.js에서 사용하는 js 파일 하나의 스코프는 글로벌 스코프가 아니다. 그렇기 때문에 Node.js에서 add 함수를 실행 시킨다면 add 함수는 클로저가 된다.

```javascript

```

### 1.4.3 클로저의 실용 사례

클로저를 가르쳐 주는 많은 예제를 보면 은닉으로 끝나는 경우가 많다. 클로저의 강력함이나 실용성은 사실 은닉에 있지 않다. 은닉은 의미 있는 기술이자 개념이지만 은닉 자체가 달성해야 하는 과제이거나 목적은 아니다.

- 이전 상황을 나중에 일어날 상황과 이어 나갈 때
- 함수로 함수를 만들거나 부분 적용을 할 때

### 1.4.5 고차 함수

고차 함수란, 함수를 다루는 함수를 말한다.

1. 함수를 인자로 받아 대신 실행하는 함수
2. 함수를 리턴하는 함수
3. 함수를 인자로 받아서 또 다른 함수를 리턴하는 함수

함수형 프로그래밍의 절반은 '고차 함수를 적극적으로 활용하는 프로그래밍'이라고도 할 수 있다.

함수형 프로그래밍은 함수에 딘자를 언제 어떻게 적용할 것인가, 함수를 인자로 언제 어떻게 적용할 것인가, 인자로 받은 함수를 언제 어디서 평가할 것인가에 대한 이야기이기도 하다.

### 1.4.7 함수를 리턴하는 함수와 부분 적용

앞서 미리 필요한 인자를 넘겨 두고 그 인자를 기억하는 클로저를 리턴하는 함수들을 확인했다. 약속된 개수의 인자를 미리 받아두고 클로저로 만들어진 함수가 추가적으로 인자를 받아 로직을 완성해 나가는 패턴이다. 이러한 기법들로 만들어진 함수들에는 bind, curry, partial 등이 있다.

bind는 this와 인자들이 부분적으로 적용된 함수를 리턴한다. bind는 왼쪽에서 부터 값을 채워야 한다는 점과 첫 번째 인자가 this를 의미한다는 점이 아쉽다.

```javascript
function add(a, b) {
  return a + b;
}

const add10 = add.bind(null, 10);
add10(20); // 30
```

이를 개선하기 위해 curry이 등장했다. curry는 함수가 필요로 하는 모든 인자를 받을 때까지 인자를 받아 두고, 인자가 모두 모이면 함수를 실행하는 패턴이다. 그러나 curry도 인자의 수가 명확하지 않는 함수의 경우에 대응하지 못하는 경우도 있다.

partial은 이러한 점을 개선했다.

```javascript
Function.prototype.partial = function () {
  let fn = this;
  let args = Array.prototype.slice.call(arguments);

  return function () {
    let arg = 0;
    for (let i = 0; i < args.length && arg < arguments.length; i++) {
      if (args[i] === undefined) args[i] = arguments[arg++];
    }
    return fn.apply(this, args);
  };
};
```

해당 함수의 인자로 undefined를 사용하고 싶을 때는 문제가 될 수 있다. 또한 초기에 partial을 실행할 때 실제 사용할 함수의 인자의 개수만큼 꼭 미리 채워야 한다는 단점이 있다. 더 큰 문제점은 partial을 여러 번 실행할 때 문제가 발생할 수 있다.

```javascript
const add3 = add.partial(undefined, undefined, 3, undefined, undefined);
add3(1, 2, 3, 4); //15
add3(50, 50, 50, 50); //15 Error
```

실행될 때 클로저의 args를 직접 변경하기 때문에 이러한 문제가 발생한다.

```javascript
Function.prototype.partial = function () {
  let fn = this;
  let _agrs = arguments;

  return function () {
    let args = Array.prototype.slice.call(_agrs);
    let arg = 0;
    for (let i = 0; i < args.length && arg < arguments.length; i++) {
      if (args[i] === undefined) args[i] = arguments[arg++];
    }
    return fn.apply(this, args);
  };
};
```
