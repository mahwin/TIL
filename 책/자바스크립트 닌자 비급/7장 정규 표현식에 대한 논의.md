# 7 정규 표현식에 대한 논의

정규 표현식은 현대적인 개발에 필수적인 요소다. 다양한 일을 처리하는데 일상적으로 정규 표현식이 사용된다.

- 노드의 문자열 변경
- 셀렉터 표현식 내에서 부분 셀렉터의 위치 검색
- 엘리먼트가 특정한 클래스 명을 가지고 있는지 판별
- 그 외의 여러 가지 용도

## 7.1 정규 표현식이 멋진 이유

미국 우편번호 형식을 따르는지 확인하는 함수를 짜보자. (우편번호는 xxxxx-xxxx 형식이다.)

```javascript
function isThisAZipCode(candidate) {
  if (typeof candidate !== "string" || candidate.length !== 10) return false;

  for (var n = 0; n < candidate.length; n++) {
    if (n === 5) {
      if (candidate.charAt(n) !== "-") return false;
    } else {
      var c = candidate.charAt(n);
      if (c < "0" || c > "9") return false;
    }
  }
  return true;
}

function isThisAZipCode(candidate) {
  return /^\d{5}-\d{4}$/.test(candidate);
}
```

### 7.2.1 정규 표현식에 대한 설명

정규 표현식은 텍스트 내에서 일치하는 문자열을 찾기 위해 문자열의 패턴을 표현하는 방식이라고 할 수 있다.
정규 표현식은 이런 패턴을 정의할 수 있도록 하는 용어와 연산자로 구성되어 있다.

자바스크립트에서 정규 표현식을 생성하는 방법은, 대분의 객체 타입과 마찬가지로, 두 가지가 있다.

하나는 정규 표현식 리터럴을 이용하는 것이고 다른 하나는 RegExp 객체의 인스턴스를 생성하는 방식이다.

정규 표현 리터럴은 / /를 사용할 수 있다.
RegExp 객체의 인스턴스를 생성하는 방법은 new RegExp() 생성자를 사용하는 것이다.

```js
// test라는 문자열을 기준으로 해보자

const patten = /test/;
const pattern = new RegExp("test");
```

정규 표현식을 표현하는 것보다 리터럴 구문을 선호하는 이유 중 하나는 정규 표현식 내에서 역슬래시가 중요한 역할을 담당하기 때문이다.

역슬래시는 문자열 리터럴에서도 이스케이핑 문자로 사용되기 때문에 문자열 리터럴 내에서 역슬래시를 이용하려면 역슬래시를 두 개 붙여서 사용해야 한다.

정규 표현식에는 함께 사용할 수 있는 플래그가 세 가지 있다.

- i 정규 표현식이 대소문자를 구별하지 않도록 한다.
  - /test/i는 'test', 'Test', 'TEST' 등을 모두 일치시킨다.
- g 맨 처음 나타나는 부분과 단 한 번만 매치시키는 기본 설정인 local과는 반대로 지정된 패턴에 해당하는 모든 부분을 매치시킨다.
- m 여러 줄을 포함하고 있는 문자열, 예를 들어 textarea의 값과 같이 여러 줄로 구성될 수 있는 문자열을 대상으로 매치할 수 있게 해준다.

위의 플래그는 함께 사용할 수 있다. 사용 예시는 아래와 같다.

```js
const pattern = /test/gi;
const patten = new RegExp("test", "gi");
```

### 7.2.2 용어(Terms)와 연산자

정규 표현식은 우리가 친숙하게 여기는 대부분의 다른 표현식들처럼 용어와 용어에 어떤 자격을 부여하는 연산자들로 구성되어 있다.

`정확히 같은 부분 매칭하기`

test는 말 그대로 t 다음에 e 다음에 s 다음에 t가 나오는 문자열을 찾는다.

`문자 클래스를 이용해서 매칭하기`

보통 문자 하나를 콕 짚어서 매치하기보다는 정해진 문자들 중에서 하나를 매치하려는 경우가 많다. 이때 대괄호 사이에 매치시키려는 문자들의 집합을 지정할 수 있다.

[abc]

반대로 해당 문자를 제외한 대상을 매치시키려면 ^를 사용한다.

[^abc]

-를 이용해서 범위를 지정할수도 있다.

[abcdefghijklmnopqrstuvwxyz]
[a-z]
[0123456789]
[0-9]

`이스케이핑`

정규 표현식 내에서 모든 문자들이 문자 그대로를 의미하지는 않는다. 앞에서 살펴본 [,],-,^ 등은 특별한 의미를 가지고 있다. 이런 문자들을 문자 그대로로 취급하려면 역슬래시를 사용해야 한다.

`시작과 끝`

캐럿(^) 문자는 정규 표현식의 첫 번째 문자로 사용되었을 때 문자열의 시작과 매치가 된다.
/^test/는 test로 시작하는 문자열과 매치된다.

- 주의할 점은 ^ 문자는 문자 집합의 역집합을 나타내는 데도 사용된다.

달러($) 표시는 지정한 패턴이 문자열의 끝에 와야 한다는 것을 의미한다.

`반복된 출현`

a가 연속으로 4번 나오는 것을 매치하려면 /aaaa/를 사용한다. 반복 조건을 지정할 수도 있다.

- 문자 뒤에 ?를 두면 문자가 있거나 없는 경우를 지정할 수 있다. 딱 한번만 있거나 없거나를 의미한다.
  - t?est는 test와 est를 매치시킨다.
- 문자가 한 번 이상 나타나는 것을 원한다면 +를 사용한다.
  - t+est는 test ttest tttest 등을 매치시킨다.
- 문자가 0번 이상 나타는 것은 \*를 사용한다.
  - t\*est는 est test ttest tttest 등을 매치시킨다.
- {} 사이에 반복 횟수를 지정하면 정해진 횟수만큼 반복되는 경우를 나타낼 수 있다.
- {n, m}을 사용하면 n번에서 m번까지 반복되는 경우를 나타낼 수 있다.
  - /a{4}/ => /aaaa/
  - /a{1,10}/ => /a/, /aa/, /aaa/, /aaaa/, /aaaaa/, /aaaaaa/, /aaaaaaa/, /aaaaaaaa/, /aaaaaaaaa/, /aaaaaaaaaa/
  - /a{1,}/ => /a/, /aa/, /aaa/, /aaaa/, /aaaaa/, /aaaaaa/, /aaaaaaa/, /aaaaaaaa/, /aaaaaaaaa/, /aaaaaaaaaa/

이 반복 연산자들은 모두 가장 길게 일치하는 부분을 찾는 방식이나 가장 짧게 일치하는 부분을 찾는 방식으로 동작하게 할 수 있다. 기본적으로 모두 가장 길게 일치하는 부분을 찾는 방식으로 동작한다.
a+?와 같이 연산자 뒤에 ?를 붙이면 최소한으로 일치하는 부분을 매치하다록 할 수 있다.

`미리 정의된 문자 클래스`

문자 중에서 개행 문자 같은 제어용 문자들처럼 문자로 지정하기 어려운 것들이 있다. 또한, 매치시키고자 하는 문자들의 범위가 너무 넓어서 직접 지정하기 어려운 경우도 있다. 이런 경우에는 미리 정의된 문자 클래스를 사용할 수 있다.

| 미리 정의된 용어 | 대상                                                               |
| ---------------- | ------------------------------------------------------------------ |
| \d               | 숫자와 매치된다. [0-9]와 동일하다.                                 |
| \D               | 숫자가 아닌 것과 매치된다. [^0-9]와 동일하다.                      |
| \w               | _를 포함한 영어 알파벳과 문자와 매치된다. [a-zA-Z0-9_]와 동일하다. |
| \W               | 영어 알파벳과 문자 \_가 아닌 모든 문자                             |
| \s               | 공백 문자와 매치된다. (탭, 공백, 폼피드)                           |
| \S               | 공백 문자가 아닌 모든 문자와 매치된다.                             |
| \t               | 탭 문자와 매치된다.                                                |
| \b               | 백스페이스                                                         |
| \r               | 개행 문자                                                          |
| \n               | 줄바꿈 문자                                                        |
| .                | 줄바꿈을 제외한 모든 문자                                          |

`그룹핑`

용어들로 이뤄진 그룹에 이런 연산자를 적용하고자 한다면 ()를 사용할 수 있다.

/(ab)+/는 'ab'가 한 번 이상 반복되는 문자열을 매치시킨다.

`선택`

선택은 | 문자를 이용해서 표현할 수 있다. 예를 들어 /a|b/는 'a'나 'b'에 매치가 된다. /(ab)+|(cd)+/는 ab 또는 cd가 1번 이상 나타는 것에 매치가 된다.

`역참조`

정규 표현식에서 표현할 수 있는 가장 복잡한 용어는 정규 표현식 내에 정의된 캡처를 나중에 사용하는 역참조이다.

역참조는 역슬래시 뒤에 참조할 캡처의 번호를 쓰는 방법으로 표현하는데 번호는 1부터 시작하고 \1, \2등이 된다.

/^([dtn])a\1/를 살펴보자.

이것은 d나 t나 n으로 시작하고 뒤에 a가 오고 그 뒤에 앞에서 시작한 값이 오는 패턴이다. [dtn]a[dtn]과는 다르다.

XML 같은 마크업 엘리먼트를 매치하는 경우에 유용하다.

<(\w+)>(.+)<\/\1>

위처럼 <strong>이면 </strong>과 같은 닫는 태그를 매치시키는 패턴을 만들 수 있다.

## 7.3 정규 표현식 컴파일하기

정규 표현식은 여러 단계의 처리과정을 거친다. 각 단계에서 어떤 일들이 일어나는지 이해하면 정규 표현식을 사용하는 자바스크립트 코드를 최적화하는데 도움이 될 수 있다. 여러 단계 중 두 가지 주요한 단계는 컴파일과 실행이다.

정규 표현식이 처음에 만들어지면 컴파일이 일어난다. 컴파일된 정규 표현식으로 문자열 내의 패턴을 찾으려고 하는 것이 바로 실행이다. 컴파일 과정에서 자바스크립트 엔진은 정규 표현식을 분석하고, 정규 표현식은 내부적인 표현방식으로 변환된다. 정규 표현식을 분석하고 변환하는 단계는 정규 표현식이 만들어질 때마다 일어난다.

그렇기에 캐싱을 이용해서 컴파일을 최적화할 수 있고, 대부분의 브라우저에서는 자동으로 캐싱한다.

## 7.4 매치된 부분을 캡처하기

정규 표현식의 유용함은 검색한 결과를 저장해 놓고, 이를 이용해서 다른 일을 하고자 할 때 드러난다. 문자열이 어떤 패턴과 일치하는지 알아내는 것은 시작일 뿐이다.

### 7.4.1 간단한 캡처 실행해 보기

복잡한 문자열에 포함되어 있는 어떤 값을 추출하려는 상황을 떠올려보자. 아주 오래된 IE의 불투명도를 정규식을 이용해서 뽑아내보자.

```html
<div id="opacity" style="opacity:0.5;filter:alpha(opacity=50)"></div>

<script>
  function getOpacity(element) {
    const filter = element.style.filter;
    return filter
      ? filter.indexOf("opacity=") >= 0
        ? `${parseFloat(filter.match(/opacity=([^)]+)/)[1]) / 100}`
        : ""
      : elem.style.opacity;
  }
</script>
```

match 함수는 일치하는 부분을 찾아내면 캡처된 값들의 배열을 반환한다. 항상 첫 번째 인덱스에는 일치하는 내용 전체고, 그 뒤에는 캡처된 내용이 순서대로 저장되어 있다.

ex) ['opacity=50', '50', index: 25, input: 'opacity:0.5;filter:alpha(opacity=50)', groups: undefined]

### 7.4.2 전역 정규 표현식을 이용해서 일치하는 부분을 찾기

g 플래그가 설정된 전역 정규 표현식을 이용하면 match 메서드는 조금 다른 값을 반환한다. 여전히 결과 값이 담긴 배열을 반환하기는 하지만 전역 정규 표현식은 대상 문자열 내에서 첫 번째 매치되는 문자열만 찾지 않고 모든 매치되는 문자열을 찾아낸다. 이때 캡처는 반환하지 않는다.

```js
const html = '<div class="test"><b>Hello</b> <i>world!</i></div>';
const reg = /<(\/?)(\w+)([^>]*?)>/;
const matches = html.match(reg);
matches[0] === "<div class="test">"
matches[1] === ""
matches[2] === "div"
matches[3] === " class="test""

const all = html.match(/<(\/?)(\w+)([^>]*?)>/g);
all
// ['<div class="test">', '<b>', '</b>', '<i>', '</i>', '</div>']
```

따라서 캡처가 중요한 경우라면, exec() 메서드를 활용해서 전역 정규 표현식을 이용하는 것이 좋다.
exec 메서드는 정규 표현식을 반복적으로 호출한다.

```js
const reg = /<(\/?)(\w+)([^>]*?)>/g;

while ((match = tag.exec(html) !== null)) {
  console.log(match.length === 4); // 항상 4를 리턴한다.
  console.log(match); // 전체 태그
}
```

exec 메서드는 이전 호출에 관련된 상태를 저장하고 있기 대문에, exec()를 다시 호출하면 다음으로 매치되는 부분을 검색한다.

### 7.4.3 캡처 참조하기

정규 표현식 내에 포함된 캡처를 해당 정규 표현식 내에서 다시 참조를 하고자 한다면 두 가지 경우를 생각해야 한다.

하나는 해당 매치 내에서 참조하는 경우고, 다른 하나는 치환할 문자열 내에서 참조하는 경우다.

replace() 메서드를 호출할 때 호출되는 문자열 내에서 캡처를 참조하는 다른 방법도 있다. 역참조 코드를 사용하는 대신에 $1, $2, $3 문법을 캡처의 수만큼 이용할 수 있다.

```js
"fontFamilyHello".replace(/([A-Z])/g, "-$1").toLowerCase(); // font-family-hello
```

표현식의 그룹과 캡처, 두 가지 모두 괄호로 묶어서 지정하기 때문에, 정규 표현식 처리기는 정규 표현식에 포함된 괄호쌍 중에서 표현식 그룹과 캡처를 구분할 수가 없다. 따라서 정규 표현식은 괄호로 무인 부분을 그룹인 동시에 캡처로 다룬다. 하지만 보통 정규 표현식을 작성할 때 표현식을 그룹으로 만들 필요가 있기 때문에 의도한 것보다 캡처가 더 많이 만들어지는 상황이 일어난다. 이럴 때 우리가 어떻게 해야할까?

### 7.4.4 캡처되지 않는 그룹

괄호는 두 가지 역할, 연산을 위해서 용어를 묶는 역할과 더불어 캡처를 지정하는 역할을 한다.

```js
const ninja = 'ninja-ninja-sword';
const patten = /((ninja-)+)sword/;

const match = ninja.match(patten);
match //
['ninja-ninja-sword', 'ninja-ninja-', 'ninja-', index: 0, input: 'ninja-ninja-sword', groups: undefined]

```

위 코드의 목적은 sword가 나오기 전에 ninja- 묶음이 한 번이라도 나오길 원한다. 이 정규 표현식은 잘 작동하지만 의도하는 다르게 하나 이상의 캡처가 만들어진다.

정규 표현식 문법은 괄호로 묶은 부분이 캡처를 생성하지 않도록 여는 괄호 바로 뒤에 ?:을 지정하는 표기법을 제공한다. 이것을 수동적인 하위 표현식이라고 한다.

```js
const patten = /((?:ninja-)+)sword/;
match //
['ninja-ninja-sword', 'ninja-ninja-', index: 0, input: 'ninja-ninja-sword', groups: undefined]
```

정규 표현식을 작성할 때 가능하다면, 캡처가 필요하지 않은 곳에는 캡처가 적용되지 않는 그룹을 이용하기 위해서 노력을 기울여야 한다.

## 7.5 함수를 이용해서 치환하기

replace() 메서드는 정규 표현식을 이용해서 문자열을 치환하는데 사용된다.

```js
"ABCDEfg".replace(/[A-Z]/g, "X");
// 'XXXXXfg'

function upper(all, letter) {
  return letter.toUpperCase();
}

"border-bottom-width".replace(/-(\w)/g, upper);
// 'borderBottomWidth'
```

foo=1&foo=2&blah=a&blah=b&foo=3을 foo=1,2,3&blah=a,b로 바꾸자.

```js

```
