## 소프트웨어 설계란?

소프트웨어 설계는 코드를 만들고, 테스트하고 유지보수하기 쉬운 프로그래밍 방법을 선택하기 위해 미적 감각을 사용하는 것이다.

### 계층형 설계

계층형 설계는 소프트웨어를 계층으로 구성하는 기술이다. 각 계층에 있는 함수는 바로 아래 계층에 있는 함수를 이용해 정의한다. 설계 감각을 키우면 소프트웨어를 고치고, 읽고, 테스트하고, 재사용하기 쉬운 코드를 만들기 위한 계층 구조가 무엇인지 알 수 있다.

![스크린샷 2024-06-26 오후 9 17 01](https://gist.github.com/assets/78193416/9b8f2d6c-f2e5-4842-9783-f09ebc23a878)

### 설계 감각을 키우기

`전문가의 저주`

전문가는 본인의 전문 분야를 잘 알지만, 설명은 잘 못하는 사람을 뜻한다.

`계층형 설계 감각을 키우기 위한 입력`

계층형 설계 감각을 키우기 위해 다양한 입력을 생각해볼 수 있다.

함수 본문을 기준으로

- 길이
- 복잡성
- 구체화 단계
- 함수 호출
- 프로그래밍 언어의 기능 사용

계층 구조를 기준으로

- 화살표 길이
- 응집도
- 구체화 단계

함수 시그니처

- 함수명
- 인자 이름
- 인잣값
- 리턴값

위의 단서를 토대로 계층형 설계를 위한 길잡이로 사용해 볼 수 있다.

`계층형 설계 감각을 키우기 위한 출력`

계층형 설게 감각을 키우기 위한 입력으로 할 수 있는 일은 다양하다.

조직화

- 새로운 함수를 어디에 놓을지 결정
- 함수를 다른 곳으로 이동

구현

- 구현 바꾸기
- 함수 추출하기
- 데이터 구조 바꾸기

변경

- 새 코드를 작성할 곳 선택하기
- 적절한 수준의 구체화 단계 결정하기

### 계층형 설계 패턴

대표적인 계층형 설계의 네 가지 패턴을 살펴보자

#### 패턴 1: 직접 구현

직접 구현은 계층형 설계 구조를 만드는 데 도움이 된다.
함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절한 구체화 수준에서 해결해야 한다.

#### 패턴 2: 추상화 벽

호출 그래프에 어떤 계층은 중요한 세부 구현을 감추고 인터페이스를 제공한다. 인터페이스를 사용하여 코드를 만들면 높은 차원으로 생각할 수 있다. 고수준의 추상화 단계만 생각하면 되기 때문에 두뇌 용량의 한계를 극복할 수 있다.

#### 패턴 3: 작은 인터페이스

시스템이 커질수록 비즈니스 개념을 나타내는 중요한 인터페이스는 작고 강력한 동작으로 구성하는 것이 좋다. 다른 동작도 직간접적으로 최소한의 인터페이스를 유지하면서 정의해야 한다.

#### 패턴 4: 편리한 계층

계층형 설계 패턴과 실천 방법은 개발자의 요구를 만족시키면서 비즈니스 문제를 잘 풀 수 있어야 한다. 소프트웨어를 더 빠르고 고품질로 제공하는 데 도움이 되는 계층에 시간을 투자해야 한다.

각 패턴을 좀 더 자세히 알아보자.

`패턴 1. 직접 구현`

계층 구조는 강력한 기능을 하는 함수가 있더라도 복잡하지 않게 함수를 표현해야 한다.

장바구니에서 넥타이가 있고 클립이 없다면 클립을 무료로 제공하는 프로모션을 추가하는 코드를 작성해보자.

```javascript
function freeTieClip(cart) {
  let hasTie = false;
  let hasTieClip = false;
  for (const item of cart) {
    if (item.name === "tie") hasTie = true;

    if (item.name === "tie clip") hasTieClip = true;
  }

  if (hasTie && !hasTieClip) {
    const tieClip = make_item("tie clip", 0);
    return add_item(cart, tieClip);
  }
  return cart;
}
```

위 코드는 정확히 작동하지만 설계 원칙을 가지고 설계하지 않아 유지보수하기 어렵다.

freeTieClip라고 하는 프로모션 관련된 로직이 과연 cart의 구조에 대해서 알아야할까?

차라리 cart안에 해당 물품이 있는지 확인하는 함수를 만들어서 사용하는 것이 더 좋다.

```javascript
function isInCart(cart, name) {
  for (const item of cart) {
    if (item.name === name) return true;
  }
  return false;
}

function freeTieClip(cart) {
  const hasTie = isInCart(cart, "tie");
  const hasTieClip = isInCart(cart, "tie clip");

  if (hasTie && !hasTieClip) {
    const tieClip = make_item("tie clip", 0);
    return add_item(cart, tieClip);
  }
}
```

호출 그래프를 만들어 함수 호출을 시각화하자.

![스크린샷 2024-06-27 오후 3 22 14](https://gist.github.com/assets/78193416/020a75ca-cc6b-45c8-b9c5-53ce61731bc7)

원본 함수는 언어 기능과 함수 호출이 섞여 있는 구조다. 이를 계선하면 다음과 같다.

![스크린샷 2024-06-27 오후 3 23 21](https://gist.github.com/assets/78193416/9830861c-fd98-4d26-a8e8-9c50b2d90296)

위 그래프는 각각의 함수가 비슷한 추상화 단계를 사용하고 있다고 판단할 수 있다.

`같은 계층에 있는 함수는 같은 목적을 가져야 한다.`

![스크린샷 2024-06-27 오후 3 31 05](https://gist.github.com/assets/78193416/248bf606-b5cf-4548-801c-c9d178fc1d57)

#### 3단계 줌 레벨

다이어그램에서 문제를 찾을 수도 있지만, 너무 많은 정보가 있어 문제가 발생된 곳을 찾기 어렵다. 계층형 설계에서 문제는 세 가지 다른 영역에서 찾을 수 있다.

1. 계층 사이에 상호 관계
2. 특정 계층의 구현
3. 특정 함수의 구현

4. 전역 줌 레벨
   전역 줌 레벨이 기본 줌 레벨이다. 계층 사이에 상호 관계를 포함해서 모든 문제 영역을 살펴볼 수 있다.

5. 계층 줌 레벨
   계층 줌 레벨은 한 계층과 연결된 바로 아래 계층을 볼 수 있는 줌 레벨이다. 계층 줌 레벨로 계층이 어떻게 구현되어 있는지 알 수 있따.

6. 함수 줌 레벨
   함수 줌 레벨로 함수 하나와 아래 연결된 함수들을 볼 수 있다.

직접 구현 패턴을 사용하면 모든 화살표가 같은 길이를 가져야 한다. 화살표의 길이가 다른 것은 같은 구체화 수준이 아니라는 증거이다.

```javascript
function remove_item_by_name(cart, name) {
  let idx = null;
  for (const item of cart) {
    if (item.name === name) idx = i;
  }

  if (idx !== null) return removeItems(cart, idx, 1);
  return cart;
}

function remove_item_by_name(cart, name) {
  const idx = indexOfItem(cart, name);
  if (idx !== null) return removeItems(cart, idx, 1);
  return cart;
}

function indexOfItem(cart, name) {
  for (const [i, item] of cart.entries()) {
    if (item.name === name) return i;
  }
  return null;
}
```

![스크린샷 2024-06-27 오후 3 51 23](https://gist.github.com/assets/78193416/abccd75c-1d3f-4d9d-aa48-b8e732cba6c5)

### 직접 구현 패턴 리뷰

`직접 구현한 코드는 한 단계의 구체화 수준에 관한 문제만 해결한다.`

코드가 서로 다른 구체화 단계에 있다면 읽기 어렵고 수정하기 어렵다. 코드를 읽을 때 이해해야 할 것이 많이 있는데 구체화 단계가 다르다면 이해하기 어렵다.

`계층형 설계는 특정 구체화 단계에 집중할 수 있게 돕는다.`

코드에 있는 다양한 단서를 통해 구체화 수준에 집중하다 보면 설계 감각을 키울 수 있다.

`호출 그래프는 구체화 단계에 대한 풍부한 단서를 보여준다.`

코드에는 설계를 개선하기 위한 단서가 많이 있다. 하지만 큰 기름으로 한 번에 보기에는 너무 많은 정보가 있다. 호출 그래프는 함수가 서로 어떻게 연결되어 있느지 보여준다. 함수 시그니처와 본문, 호출 그래프와 같은 다양한 단서를 가지고 직접 구현 패턴을 적용할 수 있다.

`함수를 추출하면 더 일반적인 함수로 만들 수 있다.`

함수에 직접 구현 패턴을 적용하는 방법의 하나는 함수가 더 구체적인 내용을 두라지 않도록 함수를 일반적인 함수로 빼내는 것이다. 일반적인 함수는 보통 구체적인 내용을 하나만 다루기 때문에 테스트하기 쉽다.

`일반적인 함수가 많을수록 재사용하기 좋다.`

함수로 빼내면 재사용할 수 있는 곳이 보인다. 중복 코드를 찾기 위해 함수를 빼내는 것과는 다르다. 구현을 명확하게 하기 위해 일반적인 함수를 빼내는 것이다. 일반적인 함수는 구체적인 함수보다 더 많은 곳에서 쓸 수 있다.

`복잡성을 감추지 않는다.`

직접 구현 패턴을 적용한 코드처럼 보이게 만드는 것은 쉽다. 명확하지 않은 코드를 감추기 위해 도우미 함수를 만들면 된다. 이렇게 하는 것은 계층형 설계가 아니다. 계층형 설계에서 모든 계층은 바로 아래 계층에 의존해야 한다. 복잡한 코드를 같은 계층으로 옮기면 안 된다. 더 낮은 구체화 수준을 가진 일반적인 함수를 만들어 소프트웨어에 직접 구현 패턴을 적용해야 한다.

### 정리

- 계층형 설계는 코드를 추상화 계층으로 구성한다. 각 계층을 볼 때 다른 계층에 구체적인 내용은 몰라도 된다.
- 문제 해결을 위한 함수를 구현할 때 어떤 구체화 단계로 쓸지 결정하는 것이 중요하다.
- 함수가 어떤 계층에 속할지 알려준느 요소는 함수 이름과 본문, 호출 그래프 등이 있다.
- 함수 이름은 의도를 알려준다. 비슷한 모겆ㄱ의 이름을 가진 함수를 함께 묶을 수 있다.
- 함수 본문은 중요한 세부 사항을 알려준다. 함수 분몬은 함수가 어떤 계층 구조에 있어야 하는 지 알려준다.
- 호출 그래프로 구현이 직접적이지 않다는 것을 알 수 있다.
- 직접 구현 패턴은 함수를 명확하고 아름답게 구현해 계층을 구성할 수 있도록 알려준다.
