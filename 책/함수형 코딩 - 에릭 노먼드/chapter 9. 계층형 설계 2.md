## 패턴 2: 추상화 벽

호출 그래프에 어떤 계층은 중요한 세부 구현을 감추고 인터페이스를 제공한다. 인터페이스를 사용하여 코드를 만들면 높은 차원으로 생각할 수 있다.

추상화 벽은 여러가지 문제를 해결한다. 그중 하나는 책임을 명확하게 나누는 것이다.

추상화 벽은 세부 구현을 감춘 함수로 이루어진 계층이다. 추상화 벽에 있는 함수를 사용할 때는 구현을 전혀 몰라도 함수를 쓸 수 있다.

![스크린샷 2024-06-27 오후 4 33 02](https://gist.github.com/assets/78193416/19031e64-498b-44f9-8b4f-4911bea5ff6d)

### 세부적인 것을 감추는 것은 대칭적이다.

추상화 벽을 사용하면 세부 구현을 신경 쓰지 않아도 된다. 추상화 벽을 경계로 대칭적으로 독립적인 개발을 할 수 있다.

추상화 벽에 있는 함수를 사용하는 것은 어떤 부분에서 API와 비슷하다.

예를 들어 장바구니 데이터를 배열에서 해시 맵으로 바꾼다고 가정해보자. 아래와 같이 추상화 벽에 놓여있는 장바구니 관련 함수들만 변경하면 된다.

![스크린샷 2024-06-27 오후 4 44 00](https://gist.github.com/assets/78193416/e5b8d9d9-cf8f-470d-9b73-8c914f67c595)

- 여기서 중요한 점은 점선을 가로지르는 화살표가 없다는 것이 중요하다.

```javascript
function add_item(cart, item) {
  return objectSet(cart, item, name, item);
}
```

## 추상화 벽을 사용하기 좋을 때

추상화 벽으로 좋은 설계를 만들 수 있지만, 모든 곳에 추상화 벽을 사용하면 안 된다.

1. 쉽게 구현을 바꾸기 위해

구현에 대한 확신이 없는 경우 추상화 벽을 사용하면 구현을 간접적으로 사용할 수 있기 떄문에 나중에 구현을 바꾸기 싶다.

예를 들어 데이터를 Array 형식으로 다루는 것이 좋을지 hash map으로 다루는 것이 좋을 지 모른다면 추상화 벽을 사용하자.

2. 코드를 읽고 쓰기 쉽게 만들기 위해

추상화 벽을 사용하면 세부적인 것을 신경 쓰지 않아도 된다. 추상화 벽을 사용하면 세부적인 것은 신경 쓰지 않고 쉽게 코드를 만들 수 있고, 더 생산적인 코드를 만들 수 있다.

3. 팀 간에 조율해야 할 것을 줄이기 위해

추상화 벽을 사용하면 각 팀에 관한 구체적인 내용을 서로 신경 쓰지 않아도 일할 수 있다.

4. 주어진 문제에 집중하기 위해

추상화 벽의 진정한 가치는 문제를 해결하기 더 쉽게 만들어주는 데에 있다. 추상화 벽을 사용하면 해결하려는 문제의 구체적인 부분을 무시할 수 있다.

## 패턴 3: 작은 인터페이스

작은 인터페이스 패턴은 새로운 코드를 추가할 위치에 관한 것이다. 인터페이스를 최소화하면 하위 계층에 불필요한 기능이 쓸데없이 커지는 것을 막을 수 있다.

마케팅팀에서 시계를 할인하려고 한다고 가정하자. 장바구니에 제품을 많이 담은 사람이 시계를 구입하면 10% 할인해 주려고 한다.

관련된 함수는 추상화 벽에 존재하거나 추상화 벽 위에 존재해야 한다. 각각의 방법에 따른 비교를 해보자

`방법 1: 추상화 벽에 만들기`

- calc_total이나 isInCart 처럼 같은 계층에 있는 함수를 사용하지 못한다.

```javascript
function getsWatchDiscount(cart) {
  let total = 0;
  const names = Object.keys(cart);

  for (const name of names) {
    total += cart[name].price;
  }
  return total > 100 && cart.hasOwnProperty("watch");
}
```

`방법 2: 추상화 벽 위에 만들기`

- 추상화 벽 위에 만들면 해시 데이터 구조를 직접 접근할 수 없다.

```javascript
function getsWatchDiscount(cart) {
  const total = calcTotal(cart);
  const hasWatch = isInCart(cart, "watch");
  return total > 100 && hasWatch;
}
```

방법 2는 cart에 대한 정보를 몰라도 되기 때문에 방법 2가 더 나은 방법이다. 게다가 마케팅 팀은 반복문과 같은 low 레벨의 코드 구현에 신경쓰지 않고 싶기 때문에 추상화 벽 위에 만드는 것이 더 좋다. 또, 추상화 벽에 어떤 코드가 생긴다는 것은 추상화 벽을 기준으로 독립적인 개발을 하는 당사자들 사이에 계약이 하나 늘어난 것으로 볼 수 있다.

새로운 기능을 만들 때 하위 계층에 기능을 추가허가너 고치는 것보다 상위 계층에 만드는 것이 작은 인터페이스 패턴이라고 할 수 있다. 하나의 추가적인 예로 작은 인터페이스를 학습해보자.

`마케팅팀은 장바구니에 제품을 담을 때 로그로 남기려고 하는 상황`

장바구니에 제품을 담을 때마다 로그를 남겨보자.

```javascript
function add_item(cart, item) {
  logAddToCart(global_user_id, item);
  return objectSet(cart, item.name, item);
}
```

해당 코드는 요구사항에는 정확하게 동작하지만, 하나의 문제가 있다. log를 남기는 행위 자체가 액션이기 때문에 계산이었던 add_item 함수가 액션으로 또, add_item을 사용하는 모든 코드가 액션이 된다. 이런 관점에서 logAddToCart를 추상화 벽 위에 있는 계층에서 호출하는 것이 좋다.

### 작은 인터페이스 리뷰

추상화 벽에 만든 함수는 인터페이스라고 생각할 수 있다. 추상화 벽에 있는 인터페이스로 어떤 값의 집합에 접근하거나 값을 조작할 수 있다. 아래는 추상화 벽을 작게 만들어야 하는 이유이다.

1. 추상화 벽에 코드가 많을수록 구현이 변경되었을 때 고쳐야 할 것이 많다.
2. 추상화 벽에 있는 코드는 낮은 수준의 코드이기 때문에 더 많은 버그가 있을 수 있다.
3. 낮은 수준의 코드는 이해하기 어렵다.
4. 추상화 벽에 코드가 많을수록 팀 간 조율해야 할 것도 많다.
5. 추상화 벽에 인터페이스가 많으면 알아야 할 것이 많아 사용하기 어렵다.

이상적인 계층은 더도 덜도 아닌 필요한 함수만 가지고 있어야 한다. 함수는 바뀌어도 안 되고 나중에 더 늘어나도 안 된다. 계층이 가진 함수는 완전하고, 적고, 시간이 지나도 바뀌지 않아야 한다. 현실적으로 불가능 하기에 이런 이상적인 모습을 목표로 가려고 노력해야 한다.

## 패턴 4: 편리한 계층

계층 패턴은 언제 패턴을 적용하고 또 언제 멈춰야 하는지 실용적인 방법을 알려준다. 작업하는 코드가 편리하다고 느낀다면 설계는 조금 멈춰도 된다. 반복문은 감싸지 않고 그대로 두고 호출 화살표가 조금 길어지거나 계층이 다른 계층과 섞여도 그대로 두자. 하지만, 구체적인 것을 너무 많이 알아야 하거나, 코드가 지저분하다고 느껴진다면 다시 패턴을 적용하자. 어떤 코드도 이상적인 모습에 도달할 수 없다는 사실을 인지하자. 개발자로서 우리는 필요성과 비즈니스 요구사항을 모두를 만족시켜야 한다.

## 패턴 정리

1. 직접 구현

직접 구현은 계층형 설계 구조를 만드는 데 도움이 된다. 직접 구현된 함수를 읽을 때, 함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절한 구체화 수준에서 해결해야 한다.

2. 추상화 벽

호출 그래프에 어떤 계층은 중요한 세부 구현을 감추고 인터페이스를 제공한다. 인터페이스를 사용하여 코드를 만들면 높은 차원으로 생각할 수 있다. 고수준의 추상화 단계만 생각하면 되기 때문에 두뇌 용량의 한계를 극복할 수 있다.

3. 작은 인터페이스

시스템이 커질수록 비즈니스 개념을 나타내는 중요한 인터페이스는 작고 강력한 동작으로 구성하는 것이 좋다. 다른 동작도 직간접적으로 최소한의 인터페이스를 유지하면서 정의해야 한다.

4. 편리한 계층

계층형 설계 패턴과 실천 방법은 개발자의 요구를 만족시키면서 비즈니스 문제를 잘 풀 수 있어야 한다. 소프트웨어를 더 빠르고 고품질로 제공하는 데 도움이 되는 계층에 시간을 투자해야 한다.

### 호출 그래프

![스크린샷 2024-06-19 오후 1 51 43](https://gist.github.com/assets/78193416/998a937f-880e-4c04-a8e5-5574585ed988)

위와 같은 호출 그래프는 비기능적 요구사항을 꾸밈없이 보여준다. 기능적 요구사항은 소프트웨어가 정확히 해야 하는 일을 말하고, 비기능적 요구사항은 테스트를 어떻게 할 것인지, 재사용을 잘할 수 있는지, 유지보수하기 어렵지 않은지와 같은 요구사항들이다. 비기능적 요구사항은 소프트웨어 설계를 하는 중요한 이유이다.

### 호출 그래프의 특징

#### 그래프의 가장 위에 있는 코드가 고치기 가장 쉽다.

호출 그래프로 비즈니스 규칙처럼 자주 바뀌는 요구사항 코드를 어디에 두면 좋은지 알 수 있다. 코드 계층이 상단에 위치할수록 고치기 쉽다.

#### 아래에 있는 코드는 테스트가 중요하다.

모든 코드를 테스트하는 것은 현실적이지 않습니다. 모든 것을 테스트할 수 없다면 장기적으로 좋은 결과를 얻을 수 있는 하위 계층의 코드를 테스트해야 합니다.

#### 아래에 있는 코드가 재사용하기 더 좋다.

낮은 계층으로 내려갈수록 코드를 재사용하기 쉬워진다.

### 정리

- 추상화 벽 패턴을 사용하면 세부적인 것을 완벽히 감출 수 있기 때무에 더 높은 차원에서 생각할 수 있다.
- 작은 인터페이스 패턴을 사용하면 완성된 인터페이스에 가깝게 계층을 만들 수 있다. 중요한 비즈니스 개념을 표현하는 인터페이스는 한번 잘 만들어 놓고 더 바뀌거나 늘어나지 않아야 한다.
- 편리한 계층 패턴을 이용하면 다른 패턴을 요구 사항에 맞게 사용할 수 있다.
- 호출 그래프 구조에서 규칙을 얻을 수 있다.
