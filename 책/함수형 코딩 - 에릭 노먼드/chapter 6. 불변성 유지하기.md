## 모든 동작을 불변형으로 만들 수 있을까

제품 추가하는 로직에 대해서 카피-온-라이트 원칙을 적용하여 불변형을 적용했다. 장바구니와 관련된 모든 로직에 대해 불변형을 적용할 수 있을까?

장바구니에 대한 동작

1. 제품 개수 가져오기
2. 제품 일므으로 제품 가져오기
3. 제품 추가하기
4. 제품 이름으로 제품 빼기
5. 제품 이름으로 제품 구매 수량 바꾸기

제품에 대한 동작

1. 가격 설정하기
2. 가격 가져오기
3. 이름 가져오기

특히 `중첩된 데이터`를 불변 동작으로 구현할 수 있을지를 생각해보자.

동작은 읽기 또는 쓰기로 분류할 수 있다. 읽기 동작은 데이터를 바꾸지 않고 정보를 꺼내는 것이다.
쓰기 동작은 어떻게든 데이터를 바꾼다. 바뀌는 값은 어디서 사용될지 모르기 때문에 바뀌지 않도록 원칙이 필요하다.

장바구니 동작

1. 제품 개수 가져오기 R
2. 제품 이름으로 제품 가져오기 R
3. 제품 추가하기 W
4. 제품 이름으로 제품 빼기 W
5. 제품 이름으로 제품 구매 수량 바꾸기 W

쓰기 동작은 불변성 원칙에 따라 카피-온-라이트 원칙을 따라야한다.

자바스크립트는 기본적으로 변경 가능한 데이터 구조를 사용하기 때문에 불변성 원칙을 적용하려면 직접 구현해야 한다.

제품에 대한 동작

1. 가격 설정하기 W
2. 가격 가져오기 R
3. 이름 가져오기 R

## 카피-온-라이트 원칙 세 단계

카피-온-라이트는 세 단계로 되어 있다. 각 단계를 구현하면 불변성을 유지하면서 값을 바꿀 수 있다.

1. 복사본 만들기
2. 복사본 변경하기
3. 복사본 리턴하기

```javascript
function add_element_last(array, elem) {
  const new_array = array.slice();
  new_array.push(elem);
  return new_array;
}
```

위 함수는 기본 배열을 변경하지 않고, 정보를 리턴했기 때문에 읽기이다. `카피-온-라이트`는 쓰기 함수를 읽기로 바꾼다.

장바구에서 제품을 빼는 함수를 통해 더 자세히 알아보자

```javascript
function remove_item_by_name(cart, name) {
  const new_cart = cart.slice();
  let idx = null;
  for (let i = 0; i < new_cart.length; i++) {
    if (new_cart[i].name === name) {
      idx = i;
    }
    if (idx === null) {
      new_cart.splice(idx, 1);
      return new_cart;
    }
  }
}
```

## 쓰면서 읽기도 하는 함수 분리하기

쓰면서 읽기도 하는 함수를 분리하는 작업은 두 단계로 나눌 수 있다. 먼저 쓰기에서 읽기를 분리하고 쓰기에 카피-온-라이트를 적용해 읽기도 바꾼다.

Array.prototype.shift는 제일 앞 값을 읽으면서 기존 배열을 바꾼다. 읽기와 쓰기 작업을 나누보자

```tsx
function first_element(array) {
  return array[0];
}

function drop_first(array) {
  const copy = array.slice();
  copy.shift();
  return copy;
}

function shift(array) {
  const array_copy = array.slice();
  const first = array_copy.shift();
  return {
    first,
    rest: array_copy,
  };
}
```

## 정리

변경 가능한 데이터를 읽는 것은 액션이다.

쓰기는 데이터를 변경 가능한 구조로 만든다.

어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터이다.

불변 데이터 구조를 읽는 것은 계산이다.

쓰기를 읽기로 바꾸면 코드에 계산이 많아진다.

## 불변 데이터 구조는 충분히 빠를까

일반적으로 불변 데이터 구조는 변경 가능한 데이터 구조보다 메모리를 더 많이 쓰고 느리다. 하지만, 불변 데이터 구조를 사용하면서 대용량의 고성능 시스템을 구현하는 사례는 많이 있다. 이런 사례를 기반해 일반 애플리케이션에 쓰기 충분히 빠르다는 증거가 된다. 추가적으로 몇 가지 논점을 살펴보자.

1. 언제든 최적화할 수 있다.

불변 데이터 구조를 사용하고 속도가 느린 부분이 있다면 그때 최적화를 진행하자.

2. 가바지 컬렉터는 매우 빠르다.

대부분의 언어는 가비지 컬렉터 성능 개선을 위해 꾸준히 연구해 왔다. 어떤 가비지 컬렉터는 한두 개의 시스템 명령어로 메모리를 비울 수 있을 만큼 최적화 되어있다.

3. 생각보다 많이 복사하지 않는다.

slice로 복사하는 경우 얕은 복사를 진행한다. 얕은 복사는 같은 메모리를 가리키는 참조에 대한 복사본을 만드는 것으로 많은 메모리를 사용하지 않는다.

4. 함수형 프로그래밍 언어에는 빠른 구현체가 있다.

## 객체에 대한 카피-온-라이트

자바스크립트는 객체도 쉽게 복사본을 만들 수 있는 메서드를 제공한다.

Object.assign({},originObj)를 사용하자.

```javascript
function objectSet(object, key, value) {
  const copy = Object.assign({}, object);
  copy[key] = value;
  return copy;
}

function objectDelete(object, key) {
  const copy = Object.assign({}, object);
  delete copy[key];
  return copy;
}
```

## 정리

- 함수형 프로그래밍에서 불변 데이터가 필요하다. 계산에서는 변경 가능한 데이터에 쓰기를 할 수 없다.
- 카피-온-라이트는 데이터를 불변형으로 유지할 수 있는 원칙이다. 복사본을 만들고 원본 대신 복사본을 변경하는 것을 말한다.
- 카피-온-라이트는 값을 변경하기 전에 얕은 복사를 한다.
- 보일러 플레이트 코드를 줄이기 위해 기본적인 배열과 객체 동작에 대한 카피-온-라이트 버전을 만들어 두는 것이 좋다.
