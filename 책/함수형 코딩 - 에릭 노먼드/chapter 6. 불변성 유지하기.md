## 모든 동작을 불변형으로 만들 수 있을까

특히 중첩된 데이터를 불변 동작으로 구현할 수 있을지를 생각해보자.

동작은 읽기 또는 쓰기로 분류할 수 있다. 읽기 동작은 데이터를 바꾸지 않고 정보를 꺼내는 것이다.
쓰기 동작은 어떻게든 데이터를 바꾼다. 바뀌는 값은 어디서 사용될지 모르기 때문에 바뀌지 않도록 원칙이 필요하다.

장바구니 동작

1. 제품 개수 가져오기 R
2. 제품 이름으로 제품 가져오기 R
3. 제품 추가하기 W
4. 제품 이름으로 제품 빼기 W
5. 제품 이름으로 제품 구매 수량 바꾸기 W

쓰기 동작은 불변성 원칙에 따라 카피-온-라이트 원칙을 따라야한다.

자바스크립트는 기본적으로 변경 가능한 데이터 구조를 사용하기 때문에 불변성 원칙을 적용하려면 직접 구현해야 한다.

제품에 대한 동작

1. 가격 설정하기 W
2. 가격 가져오기 R
3. 이름 가져오기 R

## 쓰면서 읽기도 하는 함수 분리하기

쓰면서 읽기도 하는 함수를 분리하는 작업은 두 단계로 나눌 수 있다. 먼저 쓰기에서 읽기를 분리하고 쓰기에 카피-온-라이트를 적용해 읽기도 바꾼다.

Array.prototype.shift는 제일 앞 값을 읽으면서 기존 배열을 바꾼다. 읽기와 쓰기 작업을 나누보자

```tsx
function first_element(array) {
  return array[0];
}

function drop_first(array) {
  const copy = array.slice();
  copy.shift();
  return copy;
}
```

## 정리

변경 가능한 데이터를 읽는 것은 액션이다.

쓰기는 데이터를 변경 가능한 구조로 만든다.

어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터이다.

불변 데이터 구조를 읽는 것은 계산이다.

쓰기를 읽기로 바꾸면 코드에 계산이 많아진다.

## 불변 데이터 구조는 충분히 빠를까

일반적으로 불변 데이터 구조는 변경 가능한 데이터 구조보다 메모리를 더 많이 쓰고 느리다. 하지만, 불변 데이터 구조를 사용하면서 대용량의 고성능 시스템을 구현하는 사례는 많이 있다. 이런 사례를 기반해 일반 애플리케이션에 쓰기 충분히 빠르다는 증거가 된다. 추가적으로 몇 가지 논점을 살펴보자.

1. 언제든 최적화할 수 있다.

불변 데이터 구조를 사용하고 속도가 느린 부분이 있다면 그때 최적화를 진행하자.

2. 가바지 컬렉터는 매우 빠르다.

대부분의 언어는 가비지 컬렉터 성능 개선을 위해 꾸준히 연구해 왔다. 어떤 가비지 컬렉터는 한두 개의 시스템 명령어로 메모리를 비울 수 있을 만큼 최적화 되어있다.

3. 생각보다 많이 복사하지 않는다.

slice로 복사하는 경우 얕은 복사를 진행한다. 얕은 복사는 같은 메모리를 가리키는 참조에 대한 복사본을 만드는 것으로 많은 메모리를 사용하지 않는다.

4. 함수형 프로그래밍 언어에는 빠른 구현체가 있다.

## 객체에 대한 카피-온-라이트

자바스크립트는 객체도 쉽게 복사본을 만들 수 있는 메서드를 제공한다.

Object.assign({},originObj)를 사용하자.
