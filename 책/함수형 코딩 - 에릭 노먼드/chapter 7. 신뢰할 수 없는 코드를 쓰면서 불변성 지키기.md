## 레거시 코드와 불변성

레거시 코드를 함께 사용하면서 카피-온-라이트 원칙을 지킬 수 있는 방법이 있다. 이를 방어적 복사라고 한다.

바뀔 수도 있는 데이터가 신뢰할 수 없는 코드에서 안전지대로 들어올 때, 깊은 복사를 통해 데이터를 보고할 수 있다. 원본이 바뀌지 않도록 막아주기 때문에 방어적이라고 한다.

### 카피-온-라이트 코드는 신뢰할 수 없는 코드와 상호작용하기도 한다.

레거시 코드가 존재하는 경우 카피-온-라이트가 적용된 코드가 아닐 수 있기 때문에 신뢰할 수 없어서 불변성을 지킬 수 없다. 안전지대 밖으로 나가는 데이터는 잠재적으로 바뀔 수 있다. 마찬가지로 안전지대로 들어오는 데이터 역시 잠재적으로 바뀔 수 있다. 어떻게 불변성을 지키면서 데이터를 주고받을 수 있을까?

![스크린샷 2024-06-25 오후 7 34 36](https://gist.github.com/assets/78193416/3e9d8cea-f6b2-41e7-8942-394619a590f4)

### 방어작 복사는 원본이 바뀌는 것을 막아 준다.

신뢰할 수 없는 코드와 데이터를 주고받는 문제는 복사본을 만드는 것이다.

안전지대로 들어온 데이터를 깊은 복사본을 만들고 변경 가능한 원본은 버려버리자. 이런 방법으로 들어온 데이터를 보호할 수 있다. 내보내는 데이터도 깊은 복사본을 내보내면 데이터를 보호할 수 있다.

```tsx
let origin = {};

function fn() {
  const copy = deepCopy(origin);
  lecacyCode(copy);
  origin = deepCopy(copy);
}
```

## 방어적 복사 규칙

규칙 1. 데이터가 안전한 코드에서 나갈 때 복사하기

1. 불변성 데이터를 위한 깊은 복사본을 만든다.
2. 신뢰할 수 없는 코드로 복사본을 전달한다.

규칙 2. 안전한 코드로 데이터가 들어올 때 복사하기

1. 변경될 수도 있는 데이터가 들어오면 바로 깊은 복사본을 만들어 안전한 코드로 전달하기
2. 복사본을 안전한 코드애서 사용하기

### 예시 상황에 적용하기

블랙 프라이데이 프로모션 관련된 레거시 코드가 추가적으로 수행해야 된다고 가정하자

```javascript
function add_item_to_cart(name, price) {
  const item = make_cart_item(name, price);
  shopping_cart = add_item(shopping_cart, item);
  const total = calc_total(shopping_cart);
  set_cart_total_dom(total);
  update_shipping_icons(shopping_cart);
  update_tax_dom(shopping_cart);

  shopping_cart = black_friday_promotion_safe(shopping_cart);
}

function black_friday_promotion_safe(cart) {
  const cart_copy = deepCopy(cart);
  black_friday_promotion(cart_copy); // <- 레거시 코드
  return deepCopy(cart_copy);
}
```

### 방어복 복사의 일반적인 예시

`웹 API속에 방어적 복사`

대부분의 웹 기반 API는 암묵적으로 방어적 복사를 한다. JSON 데이터가 API에 요청으로 들어왔다고 해보자. 클라이언트는 데이터를 인터넷을 통해 API로 보내려고 직렬화한다. 이때 JSON 데이터는 깊은 복사본이다. 서버에서 보내는 데이터인 JSON도 역시 깊은 복사본이다.

마이크로서비스나 서비스 지향 시스템이 서로 통신할 때 방어적 복사를 한다는 점은 중요하다. 방어적 복사로 서로 다른 코드와 원칙을 가진 서비스들이 문제 없이 통신할 수 있다.

`Erlang, Elixir에서 방어적 복사`

얼랭과 엘릭서도 방어적 복사가 구현되어 있다. 얼랭에서 두 프로세스가 서로 메시지를 주고받을 때 수신자의 메일박스에 메시지가 복사된다. 또 프로세스에서 데이터가 나갈 때도 데이터를 복사한다. 방어적 복사는 얼랭 시스템이 고가용성을 보장하는 핵심 기능이다.

### 카피-온-라이트와 방어적 복사 비교

| --        | 카피-온-라이트                  | 방아적 복사                                    |
| --------- | ------------------------------- | ---------------------------------------------- |
| 사용시기  | 통제할 수 있는 데이터를 바꿀 때 | 신뢰할 수 없는 코드와 데이터를 주고받아야할 때 |
| 사용처    | 안전지대 어디서나               | 안전지대의 경게에서 데이터가 오고 갈 때        |
| 복사 방식 | 얕은 복사                       | 깊은 복사                                      |

### 깊은 복사는 얕은 복사보다 비싸다.

깊은 복사는 원본과 어떤 데이터 구조도 공유하지 않는다. 중첩된 모든 객체나 배열을 복사힌다. 얕은 복사에서는 바뀌지 않는 값이라면 원본과 복사본이 데이터를 공유한다.

### 자바스크립트에서 깊은 복사

자바스크립트는 깊은 복사를 위한 내장 함수를 제공하지 않는다. 그래서 직접 깊은 복사를 구현해야 한다. 보통은 Lodash 라이브러리에 있는 깊은 복사 함수를 쓴다. JSON 데이터라면 쉽게 깊은 복사를 구현할 수 있지만 그렇지 않다면 상당히 어렵다.

### 정리

- 방어적 복사는 불변성을 구현하는 원칙이다. 데이터가 들어오고 나갈 때 복사본을 만든다.
- 방어적 복사는 깊은 복사를 한다. 그래서 카피-온-라이트보다 비싸다.
- 카피-온-라이트와 다르게 방어적 복사는 불변성 원칙을 구현하지 않은 코드로부터 데이터를 보호한다.
- 복사본이 많이 필요하지 않기 때문에 카피-온-라이트를 더 많이 사용한다. 방어적 복사는 신뢰할 수 없는 코드와 함께 사용할 때만 사용한다.
- 깊은 복사는 위에서 아래로 중첩된 데이터 전체를 복사한다.
