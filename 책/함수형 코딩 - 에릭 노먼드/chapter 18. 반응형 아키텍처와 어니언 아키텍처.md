## 반응형 아키텍처와 어니언 아키텍처

반응형과 어니언 패턴은 서로 다른 단계에서 사용한다. 반응형 아키텍처는 순차적 액션 단계에 사용하고, 어니언 아키텍처는 서비스의 모든 단계에 사용한다. 두 패턴은 함께 사용할 수 있지만 따로 사용할 수도 있다.

`반응형 아키텍처`

반응형 아키텍처는 코드에 나타난 순차적 액션의 순서를 뒤집는다. 효과와 그 효과에 대한 원인을 분리해서 코드에 복잡하게 꼬인 부분을 풀 수 있다.

`어니언 아키텍처`

어니언 아키텍처는 웹 서비스나 온도 조절 장치 같은 현실 세계와 상호작용하기 위한 서비스 구조이다. 함수형 사고를 적용한다면 자연스럽게 쓸 수 있는 아키텍처이다.

## 변경에 대한 원인과 효과가 강력하게 결합

장바구니를 바꾸는 n가지의 방법이 있고 n 가지의 방법으로 장바구니를 바꿀 때 마다 합계나 배송 아이콘과 같은 로직이 추가적으로 호출되어야 한다.

```js
function changeCart() {
  // 변경 로직
  // calTotal()
  // calShipping()
}

function addItemCart() {
  // 추가 로직
  // calTotal()
  // calShipping()
}
```

### 반응형 아키텍처란

반응형 아키텍처는 애플리케이션을 구조화하는 방법이다. 반응형 아키텍처의 핵심 원칙은 이벤트에 대한 반응으로 일어날 일을 지정하는 것이다. 반응형 아키텍처는 웹 서비스와 UI에 잘 어울린다. 웹 서비스는 웹 요청 응답에 일어날 일을 지정하고, UI는 버튼 클릭과 같은 이벤트 응답에 일어날 일을 지정한다.

이벤트 핸들러는 X가 일어나면 Y,Z,A,B,C를 순서대로 실행하는 방식이다.

![스크린샷 2024-07-19 오후 2 57 57](https://gist.github.com/user-attachments/assets/81b08fcd-a754-4607-9e77-947d2e147a9a)

### 반응형 아키텍처의 절충점

반응형 아키텍처는 코드에 나타난 순차적 액션의 순서를 뒤집는다. X를 하고 Y를 하는 대신, X가 일어나면 언제나 Y를 실행한다. 이는 코드를 읽기 쉽고 유지보수하기도 좋다. 항상 그런것은 아니기 때문에 적절한 곳에 사용하기 위해 판단해야 한다.

`원인과 효과가 결합한 것을 분리한다.`

어떤 경우에는 원인과 효과를 분리하면 코드가 읽기 어려워질 수 있다. 하지만 코드가 더 유연하고 하려고 하는 것을 정확하게 표현할 수 있다.

`여러 단계를 파이프라인으로 처리한다.`

함수형 도구를 연결해서 파이프라인으로 계산을 조합했 듯이 반응형 아키텍처로 이와 비슷하게 액션과 계산을 조합할 수 있다.

`타임라인이 유연해진다.`

순서를 표현하는 방법을 뒤집으면 타임라인이 유연해진다.

### Cell에 대해서 알아보자

변경 가능한 값을 일급 함수로 만들어보자.

```javascript
function ValueState(initialValue) {
  let _val = initialValue;
  return {
    val: function () {
      return _val;
    },
    update: function (f) {
      const oldValue = _val;
      const newValue = f(oldValue);
      _val = newValue;
    },
  };
}
```

읽고 쓰는 코드를 명확한 메서드 호출로 변경해 상태를 일급 함수로 만들어 다루고 있다.

위에서 만든 state가 변경이 일어날 때 마다 알림을 받는 리스너를 추가하면 반응형 아키텍처를 만들 수 있다.

```javascript
function ValueState(initialValue) {
  let _val = initialValue;
  const watchers = [];
  return {
    val: function () {
      return _val;
    },
    update: function (f) {
      const oldValue = _val;
      const newValue = f(oldValue);
      if (oldValue !== newValue) {
        _val = newValue;
        watchers.forEach((w) => w(newValue));
      }
    },
    addWatcher: function (f) {
      watchers.push(f);
    },
  };
}
```

용어 정리

- watcher, event handler, listener, callback, observer
- 모두 같은 개념으로 사용된다.

### 일급 함수로 다루는 상태값의 예시

```javascript
const shopping_cart = ValueState({});

function add_item_to_cart(name, price) {
  const item = make_cart_item(name, price);
  shopping_cart.cart.update(function (cart) {
    return add_item(cart, item);
  });
  const total = calc_total(shopping_cart.val());

  // update_shipping_icons(shopping_cart.val()); <= 이 부분이 밖으로

  set_cart_total_dom(total);
  update_tax_dom(total);
}

shopping_cart.addWatcher(update_shipping_icons);
```

코드를 고치고 나니 핸들러 함수가 작아진 것을 확인할 수 있다. 또, 카트에 아이템을 삭제하거나 변경하는 작업을 하면 자동으로 배송 아이콘이 업데이트가 이루어진다.

나머지 total을 토대로 dom을 변경하는 두 가지 함수도 변경해보자.

### FormulaCell은 파생된 값을 계산한다.

어떤 셀은 다른 셀의 값을 최신으로 반영하기 위해 파생될 수 있다. FormulaCell로 이미 있는 셀에서 파생한 셀을 만들 수 있다. 다른 셀의 변화가 감지되면 값을 다시 계산하도록 하자.

위의 예제에서 shopping_cart가 변경되면 total 값이 변경되고 total 값이 변경되어야 한다.

```javascript
function FormulaCell(upstreamCell, f) {
  const myCell = ValueState(f(upstreamCell.val()));
  upstreamCell.addWatcher(function (newValue) {
    myCell.update(function () {
      return f(upstreamCell.val());
    });
    return {
      val: myCell.val,
      addWatcher: myCell.addWatcher,
    };
  });
}
```

![스크린샷 2024-07-19 오후 3 31 02](https://gist.github.com/user-attachments/assets/97e7c04d-1220-45bb-b011-bda2b107e222)

적용해보자.

```javascript
const shopping_cart = ValueState({});
const cart_total = FormulaCell(shopping_cart, calc_total);

function add_item_to_cart(name, price) {
  const item = make_cart_item(name, price);
  shopping_cart.update(function (cart) {
    return add_item(cart, item);
  });
}

shopping_cart.addWatcher(update_shipping_icons);
cart_total.addWatcher(set_cart_total_dom);
cart_total.addWatcher(update_tax_dom);
```

- total과 관련된 DOM 조작은 total을 계산하는 FormulaCell에 추가했다.
- 핸들러 함수가 훨씬 짧아진 것을 볼 수 있다.

### 함수형 프로그래밍과 변경 가능한 상태

함수형 프로그래밍을 비롯해 모드 소프트웨어는 변경 가능한 상태를 잘 관리해야 한다. 소프트웨어는 변화하는 현실 세계로부터 정보를 가져와 일부는 저장해야 한다. 중요한 것은 상태를 가능한 한 안전하게 사용해야 한다.

위에서 만든 셀 방식은 변경 가능하지만 변경 불가능한 변수에 담아두기 때문에 전역변수보다 더 안전하다.
-> 셀은 setter를 호출하는 방식으로만 값을 변경할 수 있다.

셀을 일관되게 유지하기 위해서는 다음 규칙을 따르자.

- 올바른 값으로 초기화하자.
- update()에는 계싼을 전달하자. (액션 XXX)
- 계산은 올바른 값이 주어졌다면 올바른 값을 리턴해야한다.

## 반응형 아키텍처의 특징

### 원인과 효과가 결합한 것을 분리한다.

일반적인 아키텍처의 경우 장바구니와 관련된 모든 작업에 DOM 조작이 포함되어야 한다.

ex) 추가, 삭제, 전체 삭제, ...

하지만 반응형 아키텍처의 경우 장바구니에 물건을 추가하는 작업과 DOM 조작을 분리할 수 있다.

```js
function addItem(item) {
  item.update(function (cart) {
    return add_item(cart, item);
  });
}

function deleteItem(item) {
  item.update(function (cart) {
    return delete_item(cart, item);
  });
}

item.addWatcher(function (cart) {
  update_shipping_icons(cart);
});
```

=> 위 처럼 addItem, deleteItem에 배송비 계산 로직을 추가할 필요는 없다.
=> 즉 장바구니가 변경되는 원인과 배송비가 변경되는 효과를 분리할 수 있다.

![스크린샷 2024-07-19 오후 4 06 54](https://gist.github.com/user-attachments/assets/402f76fe-abe3-4cfb-bf94-05223d7425c2)

#### 결합의 분리는 원인과 효과의 중심을 관리한다.

일반적인 아키텍처는 원인과 효과에 따라 적용해야할 코드가 NxM으로 늘어난다. 하지만, 반응형 아키텍처는 원인과 효과를 분리하면서 N+M으로 변경한다.

반응형 아키텍처를 기준으로 원인과 효과를 분리한다면 원인이나 효과를 추가할 때 관리해야할 것이 하나만 늘어난다는 장점이 있다. 하지만, 문제가 없는 이 방법으로 분리하는 것은 좋지 않다. 코드에 액션을 순서대로 표현하는 것이 더 명확할 수도 있기 때문이다.

### 여러 단계를 파이프라인으로 처리한다.

반응형 아테틱처도 간단한 액션과 계산을 조합해 복잡한 동작을 만들 수 있다. 조합된 액션은 파이프라인과 같다. 데이터가 파이프라인으로 들어가 각 단계에서 처리된다. 파이프라인은 작은 액션과 계산을 조합한 하나의 액션이라고 볼 수 있다.

각 단계에서 생성된 데이터는 다음 단계의 입력값으로 사용된다. 자바스크립트를 사용한다면 Promise로 액션과 계산을 조합해 파이프라인을 구현할 수 있다.

### 타임라인이 유연해진다.

반응형 아키텍처를 사용하면 순서를 정의하는 방법을 뒤집기 때문에 타임라인이 작은 부분으로 분리된다.

짧은 타임이라인이 좋지만 타임라인이 병렬적으로 많아지는 것도 좋지 않다. 하지만 타임라인이 공유하는 자원이 없다면 병렬적으로 많이 연결되어도 문제는 없다.

### 어니언 아키텍처

어니언 아키텍처는 반응형 아키텍처보다 더 넓은 범위에서 사용된다. 어니언 아키텍처는 서비스 전체를 구성하는 데 사용하기 때문에 바깥 세계와 상호작용을 하는 부분을 다룬다. 반응형 아키텍처와 함께 사용하면 반응형 아키텍처가 어니언 아키텍처 안에 들어 있지만 서로 의존하지는 않는다.

`반응형 아키텍처`

반응형 아키텍처는 코드에 나타난 순차적 액션의 순서를 뒤집는다. 효고와 그 효과에 대한 원인을 분리해서 코드에 복잡하게 꼬인 부분을 풀 수 있다.

`어니언 아키텍처`

어니언 아키텍처는 웹 서비스나 온도 조절 장치 같은 현실 세계와 상호작용하기 위한 서비스 구조를 만든다. 함수형 사고를 적용한다면 자연스럽게 쓸 수 있다.

#### 어니언 아키텍처란

겹겹이 쌓인 양파 모양을 하고 있는 아키텍처이다.

어니언 아키텍처는 특정 계층이 꼭 필요하다고 강제하진 않지만 보통은 3가지 큰 분류로 나눈다.

1. 인터렉션
   - 바깥세상에 영향을 주거나 받는 액션
2. 도메인 계층
   - 비즈니스 규칙을 정의하는 계산
3. 언어 계층
   - 언어 유틸리티와 라이브러리

또한, 중요한 규칙 3가지를 가지고 있다.

1. 현실 세계와 상호작용은 인터렉션 계층에서 해야 한다.
2. 계층에서 호출하는 방향은 중심 방향이다.
3. 계층은 외부에 어떤 계층이 있는지 모른다.

어니언 아키텍처는 액션과 계산의 분리, 계층형 설계 방식과 잘 맞는다.

#### 전통적인 계층형 아키텍처

웹 서버를 만들 때 사용하는 전형적인 계층의 예시이다.

웹 인터페이스 계층

- 웹 요청을 도메인으로 바꾸고 도메인을 웹 응답으로 바꾼다.

도메인 계층

- 애플리케이션 핵심 로직으로 도메인 개념에 DB 쿼리나 명령이 들어간다.

데이터베이스 계층

- 시간에 따라 바뀌는 정보를 저정한다.

해당 아키텍처는 함수형 프로그래밍 방식과 잘 맞지 않는다. 데이터 베이스 계층이 가장 아래에 있다면 그 위에 있는 모든 것이 액션이 되기 때문이다.

#### 함수형 아키텍처

<img width="523" alt="스크린샷 2024-06-24 오후 10 44 19" src="https://gist.github.com/assets/78193416/26f3a201-5c8b-45fd-8bf1-02b7205c4b1e">

눈에 띄는 차이점은 데이터베이스 계층과 도메인 계층의 관계이다. 함수형 아키텍처는 도메인 계층이 데이터베이스 계층에 의존하지 않는다. 데이터베이스 동작은 값을 바꾸거나 데이터베이스 접근하기 때문에 액션이다. 그래서 도메인 동작을 포함해 그래프에 가장 위에 있는 것까지 모두 액션이 된다.

함수형 아키텍처 그림에서 각 점선 끝을 연결하면 어니언 아키텍처와 같은 모양이 된다.

<img width="528" alt="스크린샷 2024-06-24 오후 10 48 28" src="https://gist.github.com/assets/78193416/a45af5d8-fc38-4618-8047-81ebc62c9781">

데이터 베이스는 접근하는 모든 것을 액션으로 만든다. 그래서 도메인 동작을 포함해 그래프에 가장 위에 있는 것까지 모두 액션이 된다. 따라서 데이터베이스를 도메인과 분리하는 중요하다.ㄴ

#### 변경과 재사용성

어떤 의미에서 소프트웨어 아키텍처는 변화를 다루는 일이다. 어떤 것들이 바꾸기 쉬운지를 이해하는 것이 아키텍처의 반은 이해하는 것이다.

어니언 아키텍처는 인터렉션 계층이 최외각이기 때문에 가장 바꾸기 쉽다. 어니언 아키텍처는 데이터베이스나 API 호출과 같은 외부 서비스를 바꾸기 쉽다. 가장 높은 계층에서 사용하기 떄문이다. 도메인 계층은 외부 서비스에 의존하지 않아서 테스트하기 좋다. 어니언 아키텍처는 좋은 인프라보다 좋은 도메인을 강조한다.

전형적인 아키텍처에서 도메인 규칙은 데이터베이스를 부른다. 하지만 어니언 아키텍처에서는 다른 방식으로 처리한다. 장바구니의 합계를 계산하는 웹 서비스가 있다고 하자. 요청은 /cart/cost/123으로 들어온다.

![스크린샷 2024-07-19 오후 5 22 10](https://gist.github.com/user-attachments/assets/58500af4-5923-4cef-9d70-718c0e3d8cfb)

#### 도메인 규칙은 도메인 용어를 사용한다.

프로그램의 핵심 로직을 도메인 규칙 또는 비즈니스 규칙이라고 한다. 모든 로직이 도메인 규칙이 아니므로 어떤 로직이 도메인 규칙인지 판단하기 위해 코드에 나타나는 용어를 참고할 수 있다.

도메인 규칙은 꼭 도메인 용어를 사용해야 한다. 도메인 규칙에는 제품, 이미지, 가격, 할인과 같은 용어를 사용한다.

```js
let image = newImageDB.getImage("123");
if (image === undefined) {
  image = oldImageDB.getImage("123");
}
```

해당 코드는 데이터베이스라는 용어를 사용하기 때문에 도메인 용어가 아니다. 다른 예제도 확인하자.

```js
function getWithRetries(url, retriesLeft, success, error) {
  if (retriesLeft <= 0) error("No more retries");
  else
    ajaxGet(url, success, function (e) {
      getWithRetries(url, retriesLeft - 1, success, error);
    });
}
```

재시도가 비즈니스에 중요한 기능이라고 해도 도메인 용어를 사용하지 않았기 때문에 도메인 규칙이 아니다.
해당 코드는 불안정한 네트워크 문제를 해결하기 위한 코드이다. 인터렉션 계층에 속한다.

#### 가독성을 따지자

특정 패러다임의 장점이 항상 좋은 것은 아니다. 도메인을 계산으로 만드는 것도 마찬가지다. 도메인을 항상 계산으로 만들 수 있지만, 어떤 경우는 문맥에 따라 계산보다 액션이 읽기 좋은 경우도 있다.

`가독성을 결정하는 요소`

- 사용하는 언어
- 레거시 코드와 코드 스타일
- 사용하는 라이브러리
- 개발자들의 습관

위에서 설명한 어니언 아키텍처는 가장 이상적인 모습이다. 하지만 세상에 완벽한 것은 없다. 설계자의 역할 중 하나는 현실 세계의 문제와 이상적인 다이어그램 사이를 균형 있게 유지하는 것이다.

`코드의 가독성`

일반적으로 함수형 코드는 읽기 좋다. 하지만 함수형 코드가 아닌 코드가 더 명확한 경우도 많다.

`개발 속도`

비즈니스 이유로 기능을 빨리 출시해야 하는 경우도 있다. 이런 경우에는 나중에 아키텍처에 맞춰 코드를 정리할 준비를 하는 것이 좋다.

`시스템 성능`

변경 가능한 데이터 구조는 불변 데이터 구조보다 빠르다. 성능 개선과 도메인을 계산으로 만드는 것은 따로 생각하는 것이 좋다. 최적화는 인터렉션 계층에서 하고 도메인 계층은 재사용 가능한 계산으로 만드는 것이다.

새로운 아키텍처를 적용하는 것은 항상 어려운 일이다. 하지만 능숙해지면 처음 하더라도 읽기 좋은 방법을 유지하면서 어니언 아키텍처를 적용할 수 있다.

### 정리

- 반응형 아키텍처는 코드에 나타난 순차적 액션의 순서를 뒤집는다. X를 하고 Y를 하는 것을 X가 발생하면 Y를 하도록 바꾼다.
- 반응형 아키텍처는 액션과 계산을 조합해 파이프라인을 만든다. 파이프라인은 순서대로 발생하는 작은 액션들의 조합이다.
- 읽고 쓰는 동작을 제한해 변경 가능한 일급 상태를 만든다.
- 어니언 아키텍처는 넓은 범위에서 소프트웨어를 세 개의 계층으로 나눈다. 인터렉션과 도메인, 언어 계층이다.
- 가장 바깥 인터랙션 계층은 액션으로 되어 있다. 도메인 계층과 액션을 사용하는 것을 조율한다.
- 도메인 계층은 도메인 로직과 비즈니스 로직과 같은 소프트웨어의 동작으로 되어 있다.
- 언어 계층은 소프트웨어를 만들 수 있는 언어 기능과 라이브러리로 되어 있다.
- 어니언 아키텍처는 프랙털이다. 액션의 모든 추상화 수준에서 찾을 수 있다.
