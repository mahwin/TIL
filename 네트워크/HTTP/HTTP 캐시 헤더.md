## 캐시

<img width="1099" alt="스크린샷 2024-04-19 오후 1 28 39" src="https://gist.github.com/assets/78193416/6c99a780-c015-4ff9-b999-520fa872cbb9">

- `cache-control` 헤더를 통해 브라우저 캐시에 해당 요청 결과를 저장할 수 있다.
- 다음 요청에서 브라우저 캐시를 통해 캐싱된 정보를 사용할 수 있다.

### 캐시를 적용하면 얻게 되는 장점

1. 캐시가 있다면 네트워크 트래픽을 줄일 수 있다.
2. 브라우저 로딩 속도가 빨라진다.
3. 사용자 경험을 증가시킬 수 있다.

### 캐시 만료됐을 때 어떻게 처리할 것인가?

1. 서버에서 기존 데이터를 변경함
   - 당연히 다시 다운 받아야함.
2. 서버에서 기존 데이터를 변경하지 않음
   - 변경 안 했는데, 다시 다운 받을 필요가 없음.
   - 이때 사용 우리는 검증 헤더와 조건부 요청을 사용해 최적화 가능

### 검증 헤더와 조건부 요청

#### 검증 헤더

- 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
- Last-Modified, ETag

#### 조건부 요청 헤더

- 검증 헤더로 조건에 따른 분기

  - Last-Modified: If-Modified-Since
  - ETag: If-None-Match

- 변경이 없다면 304 Not Modified
  - 브라우저 캐시로 리다이렉트해라!!
- 변경이 있다면 200 Ok, 모든 데이터를 전송

#### Last-Modified

2의 상황에서 우리는 검증 헤더와 조건부 요청을 사용할 수 있다.

- `Last-Modified` 헤더를 이용하여 리소스가 마지막으로 수정된 시간을 알 수 있다.
- 클라이언트는 `If-Modified-Since` 헤더를 통해 서버에게 리소스가 마지막으로 수정된 시간을 전달할 수 있다.
- 서버는 클라이언트가 전달한 시간과 리소스가 마지막으로 수정된 시간을 비교하여 리소스가 수정되지 않았다면 `304 Not Modified` 응답을 보낼 수 있다.
  - HTTP body는 없음
- 304 응답을 받은 클라이언트는 브라우저 캐시를 사용할 수 있다.

#### `Last-Modified 과정`

1. 캐시 유효 시간이 초과함
2. 클라이언트는 If-Modified-Since 헤더를 통해 서버에게 리소스가 마지막으로 수정된 시간을 전달
3. 서버는 데이터가 갱신되지 않았으면, 304 Not Modified + 헤더 메타 정보만 응답(body X)
4. 304 응답을 받은 클라이언트는 브라우저 캐시를 사용

#### `Last-Modified의 단점`

1. 1초 미만 단위로 캐시 조정 불가능
2. 날짜 기반의 로직 사용
3. 데이터를 A->B->A로 수정해서 데이터 결과가 똑같은 경우에도 모두 다운받음
4. 데이터가 변경됐지만, 같은 결과라고 캐싱하고 싶을 때 불가능함.

#### ETag

- Etag(Entity Tag)
- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
- 데이터가 변경되면 이 이름을 바꾸어서 변경함
- 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기!
- `캐시 제어 로직을 서버에서 관리`할 수 있다 !!!

#### `ETag 과정`

1. 캐시 유효 시간이 초과함
2. 클라이언트는 If-None-Match: "ETag" 헤더를 통해 서버에게 리소스의 ETag를 전달
3. 서버는 데이터가 갱신되지 않았으면, 304 Not Modified + 헤더 메타 정보만 응답(body X)

### 캐시 제어 헤더

#### `Cache-Control`

캐시 유효 시간, 캐시 제어

- Cache-Control: max-age
  - 캐시 유효 시간,초 단위
- Cache-Control: no-cache
  - 데이터는 캐시해도 되지만, 항상 Origin 서버에 검증해야함
  - 항상 조건부 요청을 한 뒤에 캐시 데이터를 사용해~! 라는 의미
- Cache-Control: no-store
  - 데이터에 민감한 정보가 있으니 저장하지 말아라

### 프록시 캐시

![스크린샷 2024-04-19 오후 2 10 41](https://gist.github.com/assets/78193416/2f9f2231-0d4b-4018-90c0-7ed2225ad98f)

- 웹 브라우저 캐시를 `private 캐시`라고 하고
- CDN 서버에 저장된 캐시를 `public 캐시`라고 한다.

- Cache-Control: public
  - 응답이 public 캐시에 저장되어도 됨
- Cache-Control: private
  - 응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야 함(기본값)

### 캐시 무효화

확실한 캐시 무효화 응답. 브라우저는 get 요청의 경우 자동으로 캐싱하려고 함. 이를 방지하기 위해 아래와 같은 헤더를 사용한다.

- Cache-Control: no-cache, no-store, must-revalidate
- Pragma: no-cache
  - HTTP: 1.0 하위 호환성 때문에 거의 사용하지 않음
- Cache-Control: no-cache
  - 데이터는 캐시해도 되지만, 항상 `Origin 서버에 검증`하고 사용
- Cache-Control: no-store
  - 데이터에 민감한 정보가 있으므로 저장하면 안됨
  - 메모리에 사용하고 최대한 빨리 삭제 !
- Cache-Control: must-revalidate
  - 캐시 유효 시간이라면 캐시를 사용함
  - 캐시 만료후 최초 조회시 `Origin 서버에 검증`해야함
  - Origin 서버에 접근 실패시 반드시 오류
    - 504 Gateway Timeout
- Pragma: no-cache
  - HTTP 1.0 하위 호환성 때문에 거의 사용하지 않음

> no-cache면 항상 검증하는데, 왜 must-revalidate를 조합해서 사용할까 ?

`no-cache의 기본 동작`
![스크린샷 2024-04-19 오후 2 37 19](https://gist.github.com/assets/78193416/703073ac-0d2f-406a-9941-4aa8c7369af8)

- no-cache는 항상 검증을 해야함
- 원 서버가 고장이 나면 프록시 서버 캐시라도 보여주는게 좋지않을까?
  - no-cache의 경우 프록시 서버 캐시라도 보여주게 설정할 수 있음

`must-revalidate의 동작`

![스크린샷 2024-04-19 오후 2 41 10](https://gist.github.com/assets/78193416/3e6ce960-5693-4ff5-99e2-7831974ee9a8)

- 원서버에 접근 못 하면 항상 504 Gateway Timeout을 보여줘야함
