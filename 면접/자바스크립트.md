### Q.  **var, let, const 차이점**

var는 재선언이 가능하고, let, const는 불가능하다. var,let은 재할당이 가능하고 const는 불가능하다. var는 함수 레벨 스코프이고 let, const는 블록 레벨 스코프이다.

함수로 감싸진 형태가 아닌데 var를 사용할 경우 전역 객체의 속성이 되기 때문에 사용을 최대한 지양해야 한다고 생각합니다.

var는 선언은 호이스팅되지만 할당은 호이스팅되지않고 undefined

let,const도 호이스팅되지만 참조 에러가 뜸.

var는 선언과 초기화가 동시에 일어남

let은 선언, 초기화, 할당 됨.

const는 선언 + 초기화 + 할당이 동시에 일어남.

let, const에서 발생하는데 변수가 선언되기 전에 해당 변수에 접근할 수 없는 구간을 의미한다.

### Q. 프로토타입

- 자바스크립트는 멀티 패러다임 언어구요, 멀티 패러다임에는 객체 지향 프로그래밍도 포함되어 있고, 이러한 객체 지향 프로토타입으로 구현하구요.

장점

- 동적으로 메서드를 추가할 수 있다;
- 클래스 기반은 인스턴스 마다 메서드가 별도로 할당되지만, 프로토타입 기반은 모든 인스턴스가 동일한 메서드를 공유하기 때문에 인스턴스를 생성할 때 메모리 사용량이 준다.

### Q. Redux

- 자바스크립트 앱을 위한 상태 관리 도구이다. 중앙 저장소를 제공하며, 단방향 데이터 흐름 패턴을 가지기 때문에 예측 가능한 상태를 보장한다.
- 단일 진실의 원칙
  - 전체 애플리케이션의 저장소는 단일 자바스크립트 객체에 저장되어야 한다.
- 상태는 읽기 전용
  - 상태를 직접 변경하는게 아니라 어떤 액션이 발생했다고 알리는 식으로 변경.
- 순수 함수로 변화를 만든다.

### Q. Redux-Saga

- 비동기 작업을 처리하기 위한 미들웨어 라이브러리이다.
- 제네레이터를 사용하여 비동기 작업을 쉽게 작성할 수 있도록 돕는다.
- redux-saga는 액션들을 모니터링하고, 적절한 시점에 새로운 액션을 디스패치할 수 있도록 돕는다.
  - ⇒ 리덕스 사가는 액션들을 모니터링하고, 제네레이터로 되어있다보니까 딱 필요한 시점에 필요한 액션이 디스패치 되도록 코드를 작성할 수 있게 한다.
- redux 스토어에 미들웨어로 추가하고
- function\*으로 시작하는 제네레이터 함수를 작성하고
- 액션을 모니터링하고, 특정 액션이 발생할 때 워커 사가를 호출하는 와처를 작성하고
- rootSaga: 여러 사가를 합쳐야함.

```tsx
// Worker Saga: 비동기 작업을 수행하는 함수
function* fetchDataSaga(action) {
  try {
    const data = yield call(fetchDataFromAPI, action.payload); // API 호출
    yield put(fetchDataSuccess(data)); // 성공 액션 디스패치
  } catch (error) {
    yield put(fetchDataFailure(error)); // 실패 액션 디스패치
  }
}

// Watcher Saga: 액션을 모니터링하고, 특정 액션이 발생할 때 Worker Saga를 호출
function* watchFetchData() {
  yield takeEvery(FETCH_DATA_REQUEST, fetchDataSaga);
}

// rootSaga: 여러 사가를 합치는 역할
export default function* rootSaga() {
  yield all([
    watchFetchData(),
    // 다른 사가들도 필요하다면 추가 가능
  ]);
}
```

### Q. Flux 구조

- 단방향으로 데이터 흐름을 다르는 아키텍처이다.
- 액션, 디스패처, 스토어, 뷰로 구성되어 있습니다.
- Action은 뷰의 사용자 상호작용이나 시스템 이벤트
- 디스패처가 액션을 받아 액션을 처리할 스토어에 전달한다.
- store는 애플리케이션의 상태를 저장하고 있고, 액션을 기반하여 상태를 변경하고 변경을 뷰에 알린다.

### Q. This에 대해서 설명해주세요

함수가 호출될 때 결정되는 특별한 키워드로, 함수 내부에서 현재 실행 컨텍스트를 참조합니다. this는 함수 호출 방식에 따라 다르게 바인딩 된다.

- 전역 컨텍스트
  - 호출된 함수 내부의 this는 window, global를 나타낸다.
  - 엄격 모드에서는 undefined
- 메서드 호출
  - 해당 메서드를 소유한 객체
- 생성자 함수
  - 생성한 인스턴스를 가르킨다.
- 화살표 함수
  - 부모 스코프의 this를 상속 받는다.
- bind, apply, call

### Q. 콜백 함수에 대해 설명해주세요

- 다른 함수의 인수로 전달되는 함수를 콜백이라고 하고,
- 함수의 호출 시점을 원하는 시간에 호출 싶어서 함수를 인자로 받는다고 생각이 들듬.

### Q. 렉시컬 스코프

- 함수를 어디에 **선언**하였는지에 따라 상위 스코프가 결정되는 것

### Q. 클로저

- 함수와 함수가 선언된 어휘적 환경을 함께 기억하여, 함수가 그 환경에 접근할 수 있도록 하는 기능이다.
- 함수가 선언된 환경을 기억함으로써 함수가 그 환경에 접근할 수 있도록 하는 기능이고, 접근할 수 있는 스코프는 렉시컬 스코프를 따른다.
- 렉시컬 스코프는 함수를 어디에 선언했는지에 따라 상위 스코프가 결정되는 것을 의미한다.

### Q. 호이스팅이 일어나는 이유

- 자바스크립트 엔진은 코드를 전반적으로 평가하고 나서 linebyline으로 코드를 실행한다.
- 평가하는 시점에 변수 및 함수 선언을 등록하게 된다.

함수와 함수가 선언된 어휘적 환경을 함께 기억하여, 함수가 그 환경에 접근할 수 있도록 하는 기능.

### Q. use Strict 모드

- 오류는 아니지만 오류가 될만한 코드를 미리 알려준다.
  - 선언 없이 사용한 변수는 전역 객체에 붙음.
- 자바스크립트 엔진이 최적화할 수 있도록 오류를 수정한다.
- 유효하지 않은 delete 사용 시 error 발생

### Q. ES6 문법

- 화살표 함수
- 클래스
- 템플릿 리터럴
- 해체 할당
- spread 연산자
- 매개변수 기본값
- 프로미스, async/await
- let,const

### Q. null vs undefined

- undefined
  - 자바스크립트 엔진이 할당하는 경우가 많음
  - 선언만 하고 할당하지 않은 변수
  - 객체의 존재하지 않는 속성에 접근
  - 타입이 undefined임.
- null
  - 개발자가 의도적으로 값이 없음을 표시하기 위해 사용한다.
  - 타입이 object임.

⇒ 값으로 undefined을 사용하지 말자.

⇒ 서버로 데이터를 보낼 때, json 형식으로 변환해야 하는데 그 과정에서 undefined을 값으로 가진 프로퍼티는 제거됨.

### Q. 실행 컨텍스트

- 자바스크립트 함수가 실행되는 환경을 의미한다.
- 콜스택에서 실행되고 있는 코드의 block은 실제로는 실행 컨텍스트에 감싸져있다.
- 자바스크립트 엔진은 실행 컨텍스트를 생성하고, 실행 컨텍스트를 기반하여 코드를 실행하는데
  - 왜 호이스팅이 일어나는지, 어떻게 this가 바인딩 되는지 등이 결정된다.

### Q. Promise 란?

es6에 추가된 표준 내장 객체입니다. 프로미스 이전은 콜백 패턴으로 비동기 로직을 처리했었는데, 여기에 두 가지 문제점이 있고, 이를 보완하기 위해 추가됐다.

1. 콜백 패턴은 순차적인 비동기 로직을 처리할 때 depth가 깊어지는 단점이 있다.
   => 프로미스는 then 체이닝을 통해 같은 depth에서 순차적인 로직을 짤 수 있다.
2. error을 핸들링하기 어렵다.
   => 프로미스는 then이 어떻게 연결되든 catch로 error를 핸들링할 수 있다.
3. promise.all, race를 이용하면 진짜 가치 있는 작업을 수행할 수 있다.
