### Q.  **var, let, const 차이점**

var는 재선언이 가능하고, let, const는 불가능하다. var,let은 재할당이 가능하고 const는 불가능하다. var는 함수 레벨 스코프이고 let, const는 블록 레벨 스코프이다.

함수로 감싸진 형태가 아닌데 var를 사용할 경우 전역 객체의 속성이 되기 때문에 사용을 최대한 지양해야 한다고 생각합니다.

var는 선언은 호이스팅되지만 할당은 호이스팅되지않고 undefined

let,const도 호이스팅되지만 참조 에러가 뜸.

var는 선언과 초기화가 동시에 일어남

let은 선언, 초기화, 할당 됨.

const는 선언 + 초기화 + 할당이 동시에 일어남.

let, const에서 발생하는데 변수가 선언되기 전에 해당 변수에 접근할 수 없는 구간을 의미한다.

### Q. 프로토타입

- 자바스크립트는 멀티 패러다임 언어구요, 멀티 패러다임에는 객체 지향 프로그래밍도 포함되어 있고, 이러한 객체 지향은 프로토타입으로 구현되어 있습니다.

장점

- 동적으로 메서드를 추가할 수 있다;
- 클래스 기반은 인스턴스 마다 메서드가 별도로 할당되지만, 프로토타입 기반은 모든 인스턴스가 동일한 메서드를 공유하기 때문에 인스턴스를 생성할 때 메모리 사용량이 준다.

### Q. Redux

- 자바스크립트 어플리케이션을 위한 상태 관리 도구이다. 특징으로는 데이터 흐름을 파악하기 쉽고, 상태 변화를 신뢰할 수 있다.

- 중앙 저장소를 제공하며, 단방향 데이터 흐름을 가지기 때문에 예측 가능한 상태를 보장한다.

- 단일 진실의 원칙
  - 전체 애플리케이션의 저장소는 단일 자바스크립트 객체에 저장되어야 한다.
- 상태는 읽기 전용
  - 상태를 직접 변경하는게 아니라 어떤 액션이 발생했다고 알리는 식으로 변경.
- 순수 함수로 변화를 만든다.

### Q. Redux-Saga

- 비동기 작업을 처리하기 위한 미들웨어 라이브러리이다.
- 제네레이터를 사용하여 비동기 작업을 쉽게 작성할 수 있도록 돕는다.
- redux-saga는 액션들을 모니터링하고, 적절한 시점에 새로운 액션을 디스패치할 수 있도록 돕는다.
  - ⇒ 리덕스 사가는 액션들을 모니터링하고, 제네레이터로 되어있다보니까 딱 필요한 시점에 필요한 액션이 디스패치 되도록 코드를 작성할 수 있게 한다.
- redux 스토어에 미들웨어로 추가하고
- function\*으로 시작하는 제네레이터 함수를 작성하고
- 액션을 모니터링하고, 특정 액션이 발생할 때 워커 사가를 호출하는 와처를 작성하고
- rootSaga: 여러 사가를 합쳐야함.

```tsx
// Worker Saga: 비동기 작업을 수행하는 함수
function* fetchDataSaga(action) {
  try {
    const data = yield call(fetchDataFromAPI, action.payload); // API 호출
    yield put(fetchDataSuccess(data)); // 성공 액션 디스패치
  } catch (error) {
    yield put(fetchDataFailure(error)); // 실패 액션 디스패치
  }
}

// Watcher Saga: 액션을 모니터링하고, 특정 액션이 발생할 때 Worker Saga를 호출
function* watchFetchData() {
  yield takeEvery(FETCH_DATA_REQUEST, fetchDataSaga);
}

// rootSaga: 여러 사가를 합치는 역할
export default function* rootSaga() {
  yield all([
    watchFetchData(),
    // 다른 사가들도 필요하다면 추가 가능
  ]);
}
```

### Q. Flux 구조

- 단방향으로 데이터 흐름을 다루는 아키텍처이다.
- 액션, 디스패처, 스토어, 뷰로 구성되어 있습니다.
- Action은 뷰의 사용자 상호작용이나 시스템 이벤트
- 디스패처가 액션을 받아 액션을 처리할 스토어에 전달한다.
- store는 애플리케이션의 상태를 저장하고 있고, 액션을 기반하여 상태를 변경하고 변경을 뷰에 알린다.

### Q. This에 대해서 설명해주세요

함수가 호출될 때 결정되는 특별한 키워드로, 함수 내부에서 현재 실행 컨텍스트를 참조합니다. this는 함수 호출 방식에 따라 다르게 바인딩 된다.

- 전역 컨텍스트
  - 호출된 함수 내부의 this는 window, global를 나타낸다.
  - 엄격 모드에서는 undefined
- 메서드 호출
  - 해당 메서드를 소유한 객체
- 생성자 함수
  - 생성한 인스턴스를 가르킨다.
- 화살표 함수
  - 부모 스코프의 this를 상속 받는다.
- bind, apply, call

### Q. 콜백 함수에 대해 설명해주세요

- 다른 함수의 인수로 전달되는 함수를 콜백이라고 하고,
- 함수의 호출 시점을 원하는 시간에 호출 싶어서 함수를 인자로 받는다고 생각이 들듬.

### Q. 렉시컬 스코프

- 함수를 어디에 **선언**하였는지에 따라 상위 스코프가 결정되는 것

### Q. 클로저

- 함수와 함수가 선언된 어휘적 환경을 함께 기억하여, 함수가 그 환경에 접근할 수 있도록 하는 기능이다.
- 함수가 선언된 환경을 기억함으로써 함수가 그 환경에 접근할 수 있도록 하는 기능이고, 접근할 수 있는 스코프는 렉시컬 스코프를 따른다.
- 렉시컬 스코프는 함수를 어디에 선언했는지에 따라 상위 스코프가 결정되는 것을 의미한다.

### Q. 호이스팅이 일어나는 이유

- 자바스크립트 엔진은 코드를 전반적으로 평가하고 나서 linebyline으로 코드를 실행한다.
- 평가하는 시점에 변수 및 함수 선언을 등록하게 된다.

함수와 함수가 선언된 어휘적 환경을 함께 기억하여, 함수가 그 환경에 접근할 수 있도록 하는 기능.

### Q. use Strict 모드

- 오류는 아니지만 오류가 될만한 코드를 미리 알려준다.
  - 선언 없이 사용한 변수는 전역 객체에 붙음.
- 자바스크립트 엔진이 최적화할 수 있도록 오류를 수정한다.
- 유효하지 않은 delete 사용 시 error 발생

### Q. ES6 문법

- 화살표 함수
- 클래스
- 템플릿 리터럴
- 해체 할당
- spread 연산자
- 매개변수 기본값
- 프로미스, async/await
- let,const

### Q. null vs undefined

- undefined
  - 자바스크립트 엔진이 할당하는 경우가 많음
  - 선언만 하고 할당하지 않은 변수
  - 객체의 존재하지 않는 속성에 접근
  - 타입이 undefined임.
- null
  - 개발자가 의도적으로 값이 없음을 표시하기 위해 사용한다.
  - 타입이 object임.

⇒ 값으로 undefined을 사용하지 말자.

⇒ 서버로 데이터를 보낼 때, json 형식으로 변환해야 하는데 그 과정에서 undefined을 값으로 가진 프로퍼티는 제거됨.

### Q. 실행 컨텍스트

- 자바스크립트 함수가 실행되는 환경을 의미한다.
- 콜스택에서 실행되고 있는 코드의 block은 실제로는 실행 컨텍스트에 감싸져있다.
- 자바스크립트 엔진은 실행 컨텍스트를 생성하고, 실행 컨텍스트를 기반하여 코드를 실행하는데
  - 왜 호이스팅이 일어나는지, 어떻게 this가 바인딩 되는지 등이 결정된다.

### Q. Promise 란?

es6에 추가된 표준 내장 객체입니다. 프로미스 이전은 콜백 패턴으로 비동기 로직을 처리했었는데, 여기에 두 가지 문제점이 있고, 이를 보완하기 위해 추가됐다.

1. 콜백 패턴은 순차적인 비동기 로직을 처리할 때 depth가 깊어지는 단점이 있다.
   => 프로미스는 then 체이닝을 통해 같은 depth에서 순차적인 로직을 짤 수 있다.
2. error을 핸들링하기 어렵다.
   => 프로미스는 then이 어떻게 연결되든 catch로 error를 핸들링할 수 있다.
3. promise.all, race를 이용하면 진짜 가치 있는 작업을 수행할 수 있다.

### Q. 자바스크립트에서 서브 쓰레드로 작업하는 방법

1. webWorker를 사용하기.
2. 비동기 로직으로 서브 스레드 사용하기.
   자바스크립트는 non-blocking 언어이다.
   비동기 로직을 만나면 런타인 환경이 비동기 로직을 맡아 처리 해주고,
   eventLoop에 의해 메인 스레드로 돌아오기 때문에 비동기 로직으로 작업을 구현하면 서브 스레드를 사용할 수 있다.
   Promise라는 내장 객체를 사용하면 비동기 로직을 쉽게 처리할 수 있기 떄문에 Promise를 적극적으로 사용하자~!

### Q. 자바스크립트에서 객체를 복사하는 방법을 알려주세요.

- JSON 형식이라면 직렬화와 역직렬화를 이용해서 쉽게 deep copy할 수 있습니다.
  - JSON 형식이라는 것이 중요한 점은 value로 undefined이 들어간 경우에 직렬화 역직렬화 과정에서 해당 property가 사라지는 문제가 있습니다.
- JSON 형식이 아니라면 노드를 직접적으로 탐색하면서 복사하는 방법이 있습니다.

### Q. 불변성을 지키는 방법에 대해서 말씀해주세요.

- Object.freeze
  - 객체를 수정 불가능하게 고정할 수 있습니다.
  - 주의할 점은 중첩된 객체의 경우 freeze가 동작하지 않습니다.
- Object.seal
  - 객체의 프로퍼티를 추가, 삭제할 수 없게 만들 수 있습니다.
  - 프로퍼티 값은 수정 가능합니다.
- Object.preventExtensions
  - 객체에 새로운 프로퍼티를 추가할 수 없게 만들 수 있습니다.
  - 프로퍼티 값은 수정 가능합니다.
  - 삭제도 가능합니다.

### Q. 자바스크립트의 가비지 컬렉터에 대해서 말씀해주세요.

- 자바스크립트도 가비지 컬렉션을 수행하지만 가비지 컬렉터의 호출 시점을 통제할 수는 없습니다.
  예외적으로, Node.js라는 런타임에서는 `--expose-gc` 옵션을 통해 가비지 컬렉터를 수동으로 호출할 순 있습니다.
  프론트 개발은 클라이언트의 컴퓨팅 파워를 빌려 로직을 수행하도록 하는 작업이 주를 이룬다고 생각합니다. 다량의 데이터를 다루는 작업은 보통은 백에서 진행하는 것이 일반적이라 메모리 누수 관련해서 문제가 생긴 경험은 없습니다. 재귀 호출을 잘못해서 call stack이 overflow되는 경우가 있었지만, 이는 메모리 관리 문제보다는 로직의 문제라고 생각합니다.

- 자바스크립트 엔진은 매우 효율적으로 작업을 수행하기 때문에, 메모리 누수에 관해서는 크게 고민할 필요가 없다고 생각합니다.
  물론, 클로저로 데이터를 다룰때는 가비지 컬렉션의 대상이 아니기 때문에 주의할 필요는 있습니다.
  또, 리액트의 클린업 함수를 통해서 DOM에서 발생할 수 있는 메모리 누수는 주의할 필요가 있습니다.

  1.  인터벌이나 setTimeout or AbortController를 사용하여 클린업함수에서 필요없는 작업 해제하기.
  2.  Dom의 ref 해제하기.

### Q. 클로저의 메모리 누수에 대해서 설명해주세요.

클로저는 내부 함수에서 외부 함수에 접근할 수 있는 하나의 스코프라고 생각하시면 됩니다. 클로저의 경우 메모리 누수가 중요한 이유는 클로저로 접근할 수 있는 변수의 경우 가비지 컬렉터의 대상이 아니기 때문입니다.

그래서 특정 변수가 정말 필요 없어졌다면 클로저로 갖고 있는 변수 또한 접근할 수 있고 변경할 수 있기 때문에 해당 변수에 다른 값을 넣어 메모리 누수를 방지해야 합니다.
