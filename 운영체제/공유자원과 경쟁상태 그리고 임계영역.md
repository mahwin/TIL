## 공유자원과 경쟁상태 그리고 임계영역

### 공유자원

공유자원이란 시스템 안에서 각 프로세스, 스레드가 함꼐 접근할 수 있는 자원을 의미한다.

### 경쟁 상태

경쟁상태란 두 개 이상의 프로세스가 공유자원에 접근하려고 할 때, 그 결과가 프로세스의 실행 순서에 따라 달라지는 상태를 의미한다.

### 임계 영역

임계영역은 공유자원에 접근하는 코드 영역을 의미한다. 임계영역에 진입하면 다른 프로세스가 접근할 수 없도록 보호해야 한다.

### 경쟁 상태 관리의 중요성

데이터의 정합성과 데이터의 무결성을 해치게 된다.

데이터의 정합성은 예상되는 데이터의 값이 나와야 한다는 것을 의미한다.

- 잔금이 0원이어야 하는데, 100원이 나오는 경우

데이터의 무결성은 데이터의 어떠한 규칙을 위반하면 안되는 것을 의미한다.

- 잔금이 0원인데, 출금이 되는 경우

## 뮤텍스, 세마포어, 모니터

경쟁상태를 해결하는 대표적인 방법으로 뮤텍스, 세마포어, 모니터가 있다. 이들은 모두 상호배제, 한정대기, 진행의 융통성의 조건을 만족시키며 경쟁상태를 해결한다.

- 상호 배제 : 한 프로세스가 공유자원을 사용하고 있을 때, 다른 프로세스가 접근하지 못하도록 하는 것
- 한정 대기 : 특정 프로세스가 임계영역 진입을 요청한 후 해당 요청이 승인되기 전까지 다른 프로세스가 임계영역에 진입하는 횟수를 제한하는 것.
- 진행의 융통성 : 어떤 프로세스도 임계영역을 사용하지 않는다면 어떤 프로세스도 들어갈 수 있으며, 프로세스끼리 서로 방해하지 않는다.

### 뮤텍스

뮤텍스는 공유 자원을 lock()을 통해 잠금설정하고 사용한 후에 unlock을 통해 잠금해제가 되는 것을 의미한다. 뮤텍스는 잠금을 획득한 프로세스만이 잠금을 해제할 수 있으며, 잠금을 획득한 프로세스가 잠금을 해제하기 전까지 다른 프로세스가 잠금을 획득할 수 없다.

### 세마포어

세마포어는 뮤텍스를 일반화한 형태이다. 간단한 정수 S와 wait, signal 함수로 공유자원에 대한 접근을 처리한다.

- S는 현재 사용할 수 있는 공유자원의 수
- wait()는 공유자원을 사용하는 것을 의미하며 S를 1 감소시킨다. S가 음수가 된다면 공유자원을 쓸 수 없기 때문에 프로세스는 차단되며 대기열에 프로세스를 집어넣는다.
- signal()는 S를 1 증가 시킨다. S가 0이하라면 대기열에 있던 프로세스가 동작하게 된다.

세마포어는 바이너리 세마포어와 카운팅 세마포어로 나뉜다.

바이너리 세마포어는 뮤텍스와 비슷하지만 뮤텍스는 잠금 메커니즘을 기반하고, 세마포어는 신호를 기반으로 상호 배제가 일어나는 신호 메커니즘을 사용한다는 차이가 있다.

### 모니터

모니터는 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유자원을 숨기고 해당 접근에 대해 인터페이스만 제공하는 객체이다. 이를 통해 공유자원에 대한 작업들을 순차적으로 처리하게 된다.

### 모니터와 세마포어의 차이

모니터는 세마포어보다 구현하기 쉬우며 한번에 하나의 프로세스만 공유자원에 접근할 수 있기 때문에 자동으로 상호배제가 일어난다.

세마포어는 모니터보다 구현하기 어려우며, 여러개의 프로세스가 공유자원에 접근할 수 있기 때문에 상호배제를 명시적으로 구현해야 한다.

## 교착 상태

교착상태는 두 개 이상의 프로세스가 서로가 가진 자원을 기다리며 중단된 상태를 의미한다. 교착상태는 상호배제, 점유대기, 비선점, 순환대기의 4가지 조건을 만족해야 한다.

- 상호배제 : 한번에 하나의 프로세스만이 자원을 사용할 수 있다.
- 점유대기 : 프로세스가 자원을 가진 상태에서 다른 자원을 기다리고 있는 상태이다.
- 비선점 : 프로세스가 가진 자원을 다른 프로세스가 선점할 수 없다.
- 순환대기 : 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하며 대기중인 상태.

### 교착 상태 해결 방법

1. 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계한다.
2. 교착 상태 가능성이 없을 때만 자원을 할당한다. (은행원 알고리즘)
3. 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 stop한다.
4. 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 더 커서 교착 상태가 발생하면 사용자가 작업을 종료한다.

### 은행원 알고리즘

2차원 배열 3개가 1차원 배열 2개를 사용한다.

- available[i] : i번째 자원의 사용 가능한 수
- max[i][j] : 프로세스 i가 자원 j를 요구하는 최대 수
- allocation[i][j] : 프로세스 i가 자원 j를 할당받은 수
- need[i][j] : 프로세스 i가 자원 j를 요구하는 수
- finish[i] : i번째 프로세스가 요청하는 양을 운영체제가 만족할 수 있는지를 파악할 수 있는 불리언 배열

### 은행원 알고리즘 순서도

![스크린샷 2024-03-12 오후 5 32 57](https://gist.github.com/assets/78193416/ad492eeb-acbf-479f-a7a5-7d5b79c08798)

max - allocation = need

![스크린샷 2024-03-12 오후 5 33 01](https://gist.github.com/assets/78193416/b240b03d-a7a2-4b62-b60a-d64f1b2b24a6)

1. available[i] >= need[i] 인 프로세스를 찾는다.
2. 해당 프로세스를 수행하고 available[i] += allocation[i]를 수행한다.
3. finish[i] = true로 설정한다.
4. finish[i] = false가 없거나 수행할 프로세스가 없을 때까지 1~3을 반복한다.

### 은행원 알고리즘의 단점

프로세스가 수행되기 전에 필요한 최대 자원 수를 예측해야 하는데 이게 불가능하고, 해당 알고리즘으로 생기는 자원소모량도 있으며, 프로그램의 수는 고정되어 있지 않고 항상 변하기 때문에 쓰기가 어려운 단점이 있다.

### 출처

CS 지식의 정석 | 디자인패턴 네트워크 운영체제 데이터베이스 자료구조 (최홍철)
